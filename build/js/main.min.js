!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}var e={};n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)n.d(r,o,function(n){return t[n]}.bind(null,o));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p="",n(n.s="./source/js/main.js")}({"./node_modules/sortablejs/Sortable.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**!\n * Sortable\n * @author\tRubaXa   <trash@rubaxa.org>\n * @license MIT\n */\n\n(function sortableModule(factory) {\n\t\"use strict\";\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n})(function sortableFactory() {\n\t\"use strict\";\n\n\tif (typeof window === \"undefined\" || !window.document) {\n\t\treturn function sortableError() {\n\t\t\tthrow new Error(\"Sortable.js requires a window with a document\");\n\t\t};\n\t}\n\n\tvar dragEl,\n\t\tparentEl,\n\t\tghostEl,\n\t\tcloneEl,\n\t\trootEl,\n\t\tnextEl,\n\t\tlastDownEl,\n\n\t\tscrollEl,\n\t\tscrollParentEl,\n\t\tscrollCustomFn,\n\n\t\tlastEl,\n\t\tlastCSS,\n\t\tlastParentCSS,\n\n\t\toldIndex,\n\t\tnewIndex,\n\n\t\tactiveGroup,\n\t\tputSortable,\n\n\t\tautoScroll = {},\n\n\t\ttapEvt,\n\t\ttouchEvt,\n\n\t\tmoved,\n\n\t\t/** @const */\n\t\tR_SPACE = /\\s+/g,\n\t\tR_FLOAT = /left|right|inline/,\n\n\t\texpando = 'Sortable' + (new Date).getTime(),\n\n\t\twin = window,\n\t\tdocument = win.document,\n\t\tparseInt = win.parseInt,\n\t\tsetTimeout = win.setTimeout,\n\n\t\t$ = win.jQuery || win.Zepto,\n\t\tPolymer = win.Polymer,\n\n\t\tcaptureMode = false,\n\t\tpassiveMode = false,\n\n\t\tsupportDraggable = ('draggable' in document.createElement('div')),\n\t\tsupportCssPointerEvents = (function (el) {\n\t\t\t// false when IE11\n\t\t\tif (!!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\\.|msie)/i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tel = document.createElement('x');\n\t\t\tel.style.cssText = 'pointer-events:auto';\n\t\t\treturn el.style.pointerEvents === 'auto';\n\t\t})(),\n\n\t\t_silent = false,\n\n\t\tabs = Math.abs,\n\t\tmin = Math.min,\n\n\t\tsavedInputChecked = [],\n\t\ttouchDragOverListeners = [],\n\n\t\t_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {\n\t\t\t// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n\t\t\tif (rootEl && options.scroll) {\n\t\t\t\tvar _this = rootEl[expando],\n\t\t\t\t\tel,\n\t\t\t\t\trect,\n\t\t\t\t\tsens = options.scrollSensitivity,\n\t\t\t\t\tspeed = options.scrollSpeed,\n\n\t\t\t\t\tx = evt.clientX,\n\t\t\t\t\ty = evt.clientY,\n\n\t\t\t\t\twinWidth = window.innerWidth,\n\t\t\t\t\twinHeight = window.innerHeight,\n\n\t\t\t\t\tvx,\n\t\t\t\t\tvy,\n\n\t\t\t\t\tscrollOffsetX,\n\t\t\t\t\tscrollOffsetY\n\t\t\t\t;\n\n\t\t\t\t// Delect scrollEl\n\t\t\t\tif (scrollParentEl !== rootEl) {\n\t\t\t\t\tscrollEl = options.scroll;\n\t\t\t\t\tscrollParentEl = rootEl;\n\t\t\t\t\tscrollCustomFn = options.scrollFn;\n\n\t\t\t\t\tif (scrollEl === true) {\n\t\t\t\t\t\tscrollEl = rootEl;\n\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||\n\t\t\t\t\t\t\t\t(scrollEl.offsetHeight < scrollEl.scrollHeight)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* jshint boss:true */\n\t\t\t\t\t\t} while (scrollEl = scrollEl.parentNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (scrollEl) {\n\t\t\t\t\tel = scrollEl;\n\t\t\t\t\trect = scrollEl.getBoundingClientRect();\n\t\t\t\t\tvx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);\n\t\t\t\t\tvy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);\n\t\t\t\t}\n\n\n\t\t\t\tif (!(vx || vy)) {\n\t\t\t\t\tvx = (winWidth - x <= sens) - (x <= sens);\n\t\t\t\t\tvy = (winHeight - y <= sens) - (y <= sens);\n\n\t\t\t\t\t/* jshint expr:true */\n\t\t\t\t\t(vx || vy) && (el = win);\n\t\t\t\t}\n\n\n\t\t\t\tif (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {\n\t\t\t\t\tautoScroll.el = el;\n\t\t\t\t\tautoScroll.vx = vx;\n\t\t\t\t\tautoScroll.vy = vy;\n\n\t\t\t\t\tclearInterval(autoScroll.pid);\n\n\t\t\t\t\tif (el) {\n\t\t\t\t\t\tautoScroll.pid = setInterval(function () {\n\t\t\t\t\t\t\tscrollOffsetY = vy ? vy * speed : 0;\n\t\t\t\t\t\t\tscrollOffsetX = vx ? vx * speed : 0;\n\n\t\t\t\t\t\t\tif ('function' === typeof(scrollCustomFn)) {\n\t\t\t\t\t\t\t\treturn scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (el === win) {\n\t\t\t\t\t\t\t\twin.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tel.scrollTop += scrollOffsetY;\n\t\t\t\t\t\t\t\tel.scrollLeft += scrollOffsetX;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 24);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 30),\n\n\t\t_prepareGroup = function (options) {\n\t\t\tfunction toFn(value, pull) {\n\t\t\t\tif (value === void 0 || value === true) {\n\t\t\t\t\tvalue = group.name;\n\t\t\t\t}\n\n\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn function (to, from) {\n\t\t\t\t\t\tvar fromGroup = from.options.group.name;\n\n\t\t\t\t\t\treturn pull\n\t\t\t\t\t\t\t? value\n\t\t\t\t\t\t\t: value && (value.join\n\t\t\t\t\t\t\t\t? value.indexOf(fromGroup) > -1\n\t\t\t\t\t\t\t\t: (fromGroup == value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar group = {};\n\t\t\tvar originalGroup = options.group;\n\n\t\t\tif (!originalGroup || typeof originalGroup != 'object') {\n\t\t\t\toriginalGroup = {name: originalGroup};\n\t\t\t}\n\n\t\t\tgroup.name = originalGroup.name;\n\t\t\tgroup.checkPull = toFn(originalGroup.pull, true);\n\t\t\tgroup.checkPut = toFn(originalGroup.put);\n\t\t\tgroup.revertClone = originalGroup.revertClone;\n\n\t\t\toptions.group = group;\n\t\t}\n\t;\n\n\t// Detect support a passive mode\n\ttry {\n\t\twindow.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n\t\t\tget: function () {\n\t\t\t\t// `false`, because everything starts to work incorrectly and instead of d'n'd,\n\t\t\t\t// begins the page has scrolled.\n\t\t\t\tpassiveMode = false;\n\t\t\t\tcaptureMode = {\n\t\t\t\t\tcapture: false,\n\t\t\t\t\tpassive: passiveMode\n\t\t\t\t};\n\t\t\t}\n\t\t}));\n\t} catch (err) {}\n\n\t/**\n\t * @class  Sortable\n\t * @param  {HTMLElement}  el\n\t * @param  {Object}       [options]\n\t */\n\tfunction Sortable(el, options) {\n\t\tif (!(el && el.nodeType && el.nodeType === 1)) {\n\t\t\tthrow 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);\n\t\t}\n\n\t\tthis.el = el; // root element\n\t\tthis.options = options = _extend({}, options);\n\n\n\t\t// Export instance\n\t\tel[expando] = this;\n\n\t\t// Default options\n\t\tvar defaults = {\n\t\t\tgroup: Math.random(),\n\t\t\tsort: true,\n\t\t\tdisabled: false,\n\t\t\tstore: null,\n\t\t\thandle: null,\n\t\t\tscroll: true,\n\t\t\tscrollSensitivity: 30,\n\t\t\tscrollSpeed: 10,\n\t\t\tdraggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',\n\t\t\tghostClass: 'sortable-ghost',\n\t\t\tchosenClass: 'sortable-chosen',\n\t\t\tdragClass: 'sortable-drag',\n\t\t\tignore: 'a, img',\n\t\t\tfilter: null,\n\t\t\tpreventOnFilter: true,\n\t\t\tanimation: 0,\n\t\t\tsetData: function (dataTransfer, dragEl) {\n\t\t\t\tdataTransfer.setData('Text', dragEl.textContent);\n\t\t\t},\n\t\t\tdropBubble: false,\n\t\t\tdragoverBubble: false,\n\t\t\tdataIdAttr: 'data-id',\n\t\t\tdelay: 0,\n\t\t\tforceFallback: false,\n\t\t\tfallbackClass: 'sortable-fallback',\n\t\t\tfallbackOnBody: false,\n\t\t\tfallbackTolerance: 0,\n\t\t\tfallbackOffset: {x: 0, y: 0},\n\t\t\tsupportPointer: Sortable.supportPointer !== false\n\t\t};\n\n\n\t\t// Set default options\n\t\tfor (var name in defaults) {\n\t\t\t!(name in options) && (options[name] = defaults[name]);\n\t\t}\n\n\t\t_prepareGroup(options);\n\n\t\t// Bind all private methods\n\t\tfor (var fn in this) {\n\t\t\tif (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n\t\t\t\tthis[fn] = this[fn].bind(this);\n\t\t\t}\n\t\t}\n\n\t\t// Setup drag mode\n\t\tthis.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n\t\t// Bind events\n\t\t_on(el, 'mousedown', this._onTapStart);\n\t\t_on(el, 'touchstart', this._onTapStart);\n\t\toptions.supportPointer && _on(el, 'pointerdown', this._onTapStart);\n\n\t\tif (this.nativeDraggable) {\n\t\t\t_on(el, 'dragover', this);\n\t\t\t_on(el, 'dragenter', this);\n\t\t}\n\n\t\ttouchDragOverListeners.push(this._onDragOver);\n\n\t\t// Restore sorting\n\t\toptions.store && this.sort(options.store.get(this));\n\t}\n\n\n\tSortable.prototype = /** @lends Sortable.prototype */ {\n\t\tconstructor: Sortable,\n\n\t\t_onTapStart: function (/** Event|TouchEvent */evt) {\n\t\t\tvar _this = this,\n\t\t\t\tel = this.el,\n\t\t\t\toptions = this.options,\n\t\t\t\tpreventOnFilter = options.preventOnFilter,\n\t\t\t\ttype = evt.type,\n\t\t\t\ttouch = evt.touches && evt.touches[0],\n\t\t\t\ttarget = (touch || evt).target,\n\t\t\t\toriginalTarget = evt.target.shadowRoot && (evt.path && evt.path[0]) || target,\n\t\t\t\tfilter = options.filter,\n\t\t\t\tstartIndex;\n\n\t\t\t_saveInputCheckedState(el);\n\n\n\t\t\t// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\t\t\tif (dragEl) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n\t\t\t\treturn; // only left button or enabled\n\t\t\t}\n\n\t\t\t// cancel dnd if original target is content editable\n\t\t\tif (originalTarget.isContentEditable) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttarget = _closest(target, options.draggable, el);\n\n\t\t\tif (!target) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (lastDownEl === target) {\n\t\t\t\t// Ignoring duplicate `down`\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the index of the dragged element within its parent\n\t\t\tstartIndex = _index(target, options.draggable);\n\n\t\t\t// Check filter\n\t\t\tif (typeof filter === 'function') {\n\t\t\t\tif (filter.call(this, evt, target, this)) {\n\t\t\t\t\t_dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);\n\t\t\t\t\tpreventOnFilter && evt.preventDefault();\n\t\t\t\t\treturn; // cancel dnd\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (filter) {\n\t\t\t\tfilter = filter.split(',').some(function (criteria) {\n\t\t\t\t\tcriteria = _closest(originalTarget, criteria.trim(), el);\n\n\t\t\t\t\tif (criteria) {\n\t\t\t\t\t\t_dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (filter) {\n\t\t\t\t\tpreventOnFilter && evt.preventDefault();\n\t\t\t\t\treturn; // cancel dnd\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options.handle && !_closest(originalTarget, options.handle, el)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Prepare `dragstart`\n\t\t\tthis._prepareDragStart(evt, touch, target, startIndex);\n\t\t},\n\n\t\t_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {\n\t\t\tvar _this = this,\n\t\t\t\tel = _this.el,\n\t\t\t\toptions = _this.options,\n\t\t\t\townerDocument = el.ownerDocument,\n\t\t\t\tdragStartFn;\n\n\t\t\tif (target && !dragEl && (target.parentNode === el)) {\n\t\t\t\ttapEvt = evt;\n\n\t\t\t\trootEl = el;\n\t\t\t\tdragEl = target;\n\t\t\t\tparentEl = dragEl.parentNode;\n\t\t\t\tnextEl = dragEl.nextSibling;\n\t\t\t\tlastDownEl = target;\n\t\t\t\tactiveGroup = options.group;\n\t\t\t\toldIndex = startIndex;\n\n\t\t\t\tthis._lastX = (touch || evt).clientX;\n\t\t\t\tthis._lastY = (touch || evt).clientY;\n\n\t\t\t\tdragEl.style['will-change'] = 'all';\n\n\t\t\t\tdragStartFn = function () {\n\t\t\t\t\t// Delayed drag has been triggered\n\t\t\t\t\t// we can re-enable the events: touchmove/mousemove\n\t\t\t\t\t_this._disableDelayedDrag();\n\n\t\t\t\t\t// Make the element draggable\n\t\t\t\t\tdragEl.draggable = _this.nativeDraggable;\n\n\t\t\t\t\t// Chosen item\n\t\t\t\t\t_toggleClass(dragEl, options.chosenClass, true);\n\n\t\t\t\t\t// Bind the events: dragstart/dragend\n\t\t\t\t\t_this._triggerDragStart(evt, touch);\n\n\t\t\t\t\t// Drag start event\n\t\t\t\t\t_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);\n\t\t\t\t};\n\n\t\t\t\t// Disable \"draggable\"\n\t\t\t\toptions.ignore.split(',').forEach(function (criteria) {\n\t\t\t\t\t_find(dragEl, criteria.trim(), _disableDraggable);\n\t\t\t\t});\n\n\t\t\t\t_on(ownerDocument, 'mouseup', _this._onDrop);\n\t\t\t\t_on(ownerDocument, 'touchend', _this._onDrop);\n\t\t\t\t_on(ownerDocument, 'touchcancel', _this._onDrop);\n\t\t\t\t_on(ownerDocument, 'selectstart', _this);\n\t\t\t\toptions.supportPointer && _on(ownerDocument, 'pointercancel', _this._onDrop);\n\n\t\t\t\tif (options.delay) {\n\t\t\t\t\t// If the user moves the pointer or let go the click or touch\n\t\t\t\t\t// before the delay has been reached:\n\t\t\t\t\t// disable the delayed drag\n\t\t\t\t\t_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'mousemove', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchmove', _this._disableDelayedDrag);\n\t\t\t\t\toptions.supportPointer && _on(ownerDocument, 'pointermove', _this._disableDelayedDrag);\n\n\t\t\t\t\t_this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n\t\t\t\t} else {\n\t\t\t\t\tdragStartFn();\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t},\n\n\t\t_disableDelayedDrag: function () {\n\t\t\tvar ownerDocument = this.el.ownerDocument;\n\n\t\t\tclearTimeout(this._dragStartTimer);\n\t\t\t_off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchend', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'mousemove', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchmove', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'pointermove', this._disableDelayedDrag);\n\t\t},\n\n\t\t_triggerDragStart: function (/** Event */evt, /** Touch */touch) {\n\t\t\ttouch = touch || (evt.pointerType == 'touch' ? evt : null);\n\n\t\t\tif (touch) {\n\t\t\t\t// Touch device support\n\t\t\t\ttapEvt = {\n\t\t\t\t\ttarget: dragEl,\n\t\t\t\t\tclientX: touch.clientX,\n\t\t\t\t\tclientY: touch.clientY\n\t\t\t\t};\n\n\t\t\t\tthis._onDragStart(tapEvt, 'touch');\n\t\t\t}\n\t\t\telse if (!this.nativeDraggable) {\n\t\t\t\tthis._onDragStart(tapEvt, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_on(dragEl, 'dragend', this);\n\t\t\t\t_on(rootEl, 'dragstart', this._onDragStart);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (document.selection) {\n\t\t\t\t\t// Timeout neccessary for IE9\n\t\t\t\t\t_nextTick(function () {\n\t\t\t\t\t\tdocument.selection.empty();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t}\n\t\t},\n\n\t\t_dragStarted: function () {\n\t\t\tif (rootEl && dragEl) {\n\t\t\t\tvar options = this.options;\n\n\t\t\t\t// Apply effect\n\t\t\t\t_toggleClass(dragEl, options.ghostClass, true);\n\t\t\t\t_toggleClass(dragEl, options.dragClass, false);\n\n\t\t\t\tSortable.active = this;\n\n\t\t\t\t// Drag start event\n\t\t\t\t_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex);\n\t\t\t} else {\n\t\t\t\tthis._nulling();\n\t\t\t}\n\t\t},\n\n\t\t_emulateDragOver: function () {\n\t\t\tif (touchEvt) {\n\t\t\t\tif (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._lastX = touchEvt.clientX;\n\t\t\t\tthis._lastY = touchEvt.clientY;\n\n\t\t\t\tif (!supportCssPointerEvents) {\n\t\t\t\t\t_css(ghostEl, 'display', 'none');\n\t\t\t\t}\n\n\t\t\t\tvar target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n\t\t\t\tvar parent = target;\n\t\t\t\tvar i = touchDragOverListeners.length;\n\n\t\t\t\tif (target && target.shadowRoot) {\n\t\t\t\t\ttarget = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n\t\t\t\t\tparent = target;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (parent[expando]) {\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\ttouchDragOverListeners[i]({\n\t\t\t\t\t\t\t\t\tclientX: touchEvt.clientX,\n\t\t\t\t\t\t\t\t\tclientY: touchEvt.clientY,\n\t\t\t\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\t\t\t\trootEl: parent\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget = parent; // store last element\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint boss:true */\n\t\t\t\t\twhile (parent = parent.parentNode);\n\t\t\t\t}\n\n\t\t\t\tif (!supportCssPointerEvents) {\n\t\t\t\t\t_css(ghostEl, 'display', '');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t_onTouchMove: function (/**TouchEvent*/evt) {\n\t\t\tif (tapEvt) {\n\t\t\t\tvar\toptions = this.options,\n\t\t\t\t\tfallbackTolerance = options.fallbackTolerance,\n\t\t\t\t\tfallbackOffset = options.fallbackOffset,\n\t\t\t\t\ttouch = evt.touches ? evt.touches[0] : evt,\n\t\t\t\t\tdx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,\n\t\t\t\t\tdy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,\n\t\t\t\t\ttranslate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';\n\n\t\t\t\t// only set the status to dragging, when we are actually dragging\n\t\t\t\tif (!Sortable.active) {\n\t\t\t\t\tif (fallbackTolerance &&\n\t\t\t\t\t\tmin(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._dragStarted();\n\t\t\t\t}\n\n\t\t\t\t// as well as creating the ghost element on the document body\n\t\t\t\tthis._appendGhost();\n\n\t\t\t\tmoved = true;\n\t\t\t\ttouchEvt = touch;\n\n\t\t\t\t_css(ghostEl, 'webkitTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'mozTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'msTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'transform', translate3d);\n\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\t_appendGhost: function () {\n\t\t\tif (!ghostEl) {\n\t\t\t\tvar rect = dragEl.getBoundingClientRect(),\n\t\t\t\t\tcss = _css(dragEl),\n\t\t\t\t\toptions = this.options,\n\t\t\t\t\tghostRect;\n\n\t\t\t\tghostEl = dragEl.cloneNode(true);\n\n\t\t\t\t_toggleClass(ghostEl, options.ghostClass, false);\n\t\t\t\t_toggleClass(ghostEl, options.fallbackClass, true);\n\t\t\t\t_toggleClass(ghostEl, options.dragClass, true);\n\n\t\t\t\t_css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));\n\t\t\t\t_css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));\n\t\t\t\t_css(ghostEl, 'width', rect.width);\n\t\t\t\t_css(ghostEl, 'height', rect.height);\n\t\t\t\t_css(ghostEl, 'opacity', '0.8');\n\t\t\t\t_css(ghostEl, 'position', 'fixed');\n\t\t\t\t_css(ghostEl, 'zIndex', '100000');\n\t\t\t\t_css(ghostEl, 'pointerEvents', 'none');\n\n\t\t\t\toptions.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);\n\n\t\t\t\t// Fixing dimensions.\n\t\t\t\tghostRect = ghostEl.getBoundingClientRect();\n\t\t\t\t_css(ghostEl, 'width', rect.width * 2 - ghostRect.width);\n\t\t\t\t_css(ghostEl, 'height', rect.height * 2 - ghostRect.height);\n\t\t\t}\n\t\t},\n\n\t\t_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {\n\t\t\tvar _this = this;\n\t\t\tvar dataTransfer = evt.dataTransfer;\n\t\t\tvar options = _this.options;\n\n\t\t\t_this._offUpEvents();\n\n\t\t\tif (activeGroup.checkPull(_this, _this, dragEl, evt)) {\n\t\t\t\tcloneEl = _clone(dragEl);\n\n\t\t\t\tcloneEl.draggable = false;\n\t\t\t\tcloneEl.style['will-change'] = '';\n\n\t\t\t\t_css(cloneEl, 'display', 'none');\n\t\t\t\t_toggleClass(cloneEl, _this.options.chosenClass, false);\n\n\t\t\t\t// #1143: IFrame support workaround\n\t\t\t\t_this._cloneId = _nextTick(function () {\n\t\t\t\t\trootEl.insertBefore(cloneEl, dragEl);\n\t\t\t\t\t_dispatchEvent(_this, rootEl, 'clone', dragEl);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t_toggleClass(dragEl, options.dragClass, true);\n\n\t\t\tif (useFallback) {\n\t\t\t\tif (useFallback === 'touch') {\n\t\t\t\t\t// Bind touch events\n\t\t\t\t\t_on(document, 'touchmove', _this._onTouchMove);\n\t\t\t\t\t_on(document, 'touchend', _this._onDrop);\n\t\t\t\t\t_on(document, 'touchcancel', _this._onDrop);\n\n\t\t\t\t\tif (options.supportPointer) {\n\t\t\t\t\t\t_on(document, 'pointermove', _this._onTouchMove);\n\t\t\t\t\t\t_on(document, 'pointerup', _this._onDrop);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Old brwoser\n\t\t\t\t\t_on(document, 'mousemove', _this._onTouchMove);\n\t\t\t\t\t_on(document, 'mouseup', _this._onDrop);\n\t\t\t\t}\n\n\t\t\t\t_this._loopId = setInterval(_this._emulateDragOver, 50);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dataTransfer) {\n\t\t\t\t\tdataTransfer.effectAllowed = 'move';\n\t\t\t\t\toptions.setData && options.setData.call(_this, dataTransfer, dragEl);\n\t\t\t\t}\n\n\t\t\t\t_on(document, 'drop', _this);\n\n\t\t\t\t// #1143: Бывает элемент с IFrame внутри блокирует `drop`,\n\t\t\t\t// поэтому если вызвался `mouseover`, значит надо отменять весь d'n'd.\n\t\t\t\t// Breaking Chrome 62+\n\t\t\t\t// _on(document, 'mouseover', _this);\n\n\t\t\t\t_this._dragStartId = _nextTick(_this._dragStarted);\n\t\t\t}\n\t\t},\n\n\t\t_onDragOver: function (/**Event*/evt) {\n\t\t\tvar el = this.el,\n\t\t\t\ttarget,\n\t\t\t\tdragRect,\n\t\t\t\ttargetRect,\n\t\t\t\trevert,\n\t\t\t\toptions = this.options,\n\t\t\t\tgroup = options.group,\n\t\t\t\tactiveSortable = Sortable.active,\n\t\t\t\tisOwner = (activeGroup === group),\n\t\t\t\tisMovingBetweenSortable = false,\n\t\t\t\tcanSort = options.sort;\n\n\t\t\tif (evt.preventDefault !== void 0) {\n\t\t\t\tevt.preventDefault();\n\t\t\t\t!options.dragoverBubble && evt.stopPropagation();\n\t\t\t}\n\n\t\t\tif (dragEl.animated) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmoved = true;\n\n\t\t\tif (activeSortable && !options.disabled &&\n\t\t\t\t(isOwner\n\t\t\t\t\t? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n\t\t\t\t\t: (\n\t\t\t\t\t\tputSortable === this ||\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t(activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&\n\t\t\t\t\t\t\tgroup.checkPut(this, activeSortable, dragEl, evt)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) &&\n\t\t\t\t(evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback\n\t\t\t) {\n\t\t\t\t// Smart auto-scrolling\n\t\t\t\t_autoScroll(evt, options, this.el);\n\n\t\t\t\tif (_silent) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttarget = _closest(evt.target, options.draggable, el);\n\t\t\t\tdragRect = dragEl.getBoundingClientRect();\n\n\t\t\t\tif (putSortable !== this) {\n\t\t\t\t\tputSortable = this;\n\t\t\t\t\tisMovingBetweenSortable = true;\n\t\t\t\t}\n\n\t\t\t\tif (revert) {\n\t\t\t\t\t_cloneHide(activeSortable, true);\n\t\t\t\t\tparentEl = rootEl; // actualization\n\n\t\t\t\t\tif (cloneEl || nextEl) {\n\t\t\t\t\t\trootEl.insertBefore(dragEl, cloneEl || nextEl);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!canSort) {\n\t\t\t\t\t\trootEl.appendChild(dragEl);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t\tif ((el.children.length === 0) || (el.children[0] === ghostEl) ||\n\t\t\t\t\t(el === evt.target) && (_ghostIsLast(el, evt))\n\t\t\t\t) {\n\t\t\t\t\t//assign target only if condition is true\n\t\t\t\t\tif (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {\n\t\t\t\t\t\ttarget = el.lastElementChild;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\tif (target.animated) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetRect = target.getBoundingClientRect();\n\t\t\t\t\t}\n\n\t\t\t\t\t_cloneHide(activeSortable, isOwner);\n\n\t\t\t\t\tif (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {\n\t\t\t\t\t\tif (!dragEl.contains(el)) {\n\t\t\t\t\t\t\tel.appendChild(dragEl);\n\t\t\t\t\t\t\tparentEl = el; // actualization\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._animate(dragRect, dragEl);\n\t\t\t\t\t\ttarget && this._animate(targetRect, target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {\n\t\t\t\t\tif (lastEl !== target) {\n\t\t\t\t\t\tlastEl = target;\n\t\t\t\t\t\tlastCSS = _css(target);\n\t\t\t\t\t\tlastParentCSS = _css(target.parentNode);\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetRect = target.getBoundingClientRect();\n\n\t\t\t\t\tvar width = targetRect.right - targetRect.left,\n\t\t\t\t\t\theight = targetRect.bottom - targetRect.top,\n\t\t\t\t\t\tfloating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)\n\t\t\t\t\t\t\t|| (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),\n\t\t\t\t\t\tisWide = (target.offsetWidth > dragEl.offsetWidth),\n\t\t\t\t\t\tisLong = (target.offsetHeight > dragEl.offsetHeight),\n\t\t\t\t\t\thalfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,\n\t\t\t\t\t\tnextSibling = target.nextElementSibling,\n\t\t\t\t\t\tafter = false\n\t\t\t\t\t;\n\n\t\t\t\t\tif (floating) {\n\t\t\t\t\t\tvar elTop = dragEl.offsetTop,\n\t\t\t\t\t\t\ttgTop = target.offsetTop;\n\n\t\t\t\t\t\tif (elTop === tgTop) {\n\t\t\t\t\t\t\tafter = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {\n\t\t\t\t\t\t\tafter = (evt.clientY - targetRect.top) / height > 0.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tafter = tgTop > elTop;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!isMovingBetweenSortable) {\n\t\t\t\t\t\tafter = (nextSibling !== dragEl) && !isLong || halfway && isLong;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n\t\t\t\t\tif (moveVector !== false) {\n\t\t\t\t\t\tif (moveVector === 1 || moveVector === -1) {\n\t\t\t\t\t\t\tafter = (moveVector === 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_silent = true;\n\t\t\t\t\t\tsetTimeout(_unsilent, 30);\n\n\t\t\t\t\t\t_cloneHide(activeSortable, isOwner);\n\n\t\t\t\t\t\tif (!dragEl.contains(el)) {\n\t\t\t\t\t\t\tif (after && !nextSibling) {\n\t\t\t\t\t\t\t\tel.appendChild(dragEl);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparentEl = dragEl.parentNode; // actualization\n\n\t\t\t\t\t\tthis._animate(dragRect, dragEl);\n\t\t\t\t\t\tthis._animate(targetRect, target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_animate: function (prevRect, target) {\n\t\t\tvar ms = this.options.animation;\n\n\t\t\tif (ms) {\n\t\t\t\tvar currentRect = target.getBoundingClientRect();\n\n\t\t\t\tif (prevRect.nodeType === 1) {\n\t\t\t\t\tprevRect = prevRect.getBoundingClientRect();\n\t\t\t\t}\n\n\t\t\t\t_css(target, 'transition', 'none');\n\t\t\t\t_css(target, 'transform', 'translate3d('\n\t\t\t\t\t+ (prevRect.left - currentRect.left) + 'px,'\n\t\t\t\t\t+ (prevRect.top - currentRect.top) + 'px,0)'\n\t\t\t\t);\n\n\t\t\t\ttarget.offsetWidth; // repaint\n\n\t\t\t\t_css(target, 'transition', 'all ' + ms + 'ms');\n\t\t\t\t_css(target, 'transform', 'translate3d(0,0,0)');\n\n\t\t\t\tclearTimeout(target.animated);\n\t\t\t\ttarget.animated = setTimeout(function () {\n\t\t\t\t\t_css(target, 'transition', '');\n\t\t\t\t\t_css(target, 'transform', '');\n\t\t\t\t\ttarget.animated = false;\n\t\t\t\t}, ms);\n\t\t\t}\n\t\t},\n\n\t\t_offUpEvents: function () {\n\t\t\tvar ownerDocument = this.el.ownerDocument;\n\n\t\t\t_off(document, 'touchmove', this._onTouchMove);\n\t\t\t_off(document, 'pointermove', this._onTouchMove);\n\t\t\t_off(ownerDocument, 'mouseup', this._onDrop);\n\t\t\t_off(ownerDocument, 'touchend', this._onDrop);\n\t\t\t_off(ownerDocument, 'pointerup', this._onDrop);\n\t\t\t_off(ownerDocument, 'touchcancel', this._onDrop);\n\t\t\t_off(ownerDocument, 'pointercancel', this._onDrop);\n\t\t\t_off(ownerDocument, 'selectstart', this);\n\t\t},\n\n\t\t_onDrop: function (/**Event*/evt) {\n\t\t\tvar el = this.el,\n\t\t\t\toptions = this.options;\n\n\t\t\tclearInterval(this._loopId);\n\t\t\tclearInterval(autoScroll.pid);\n\t\t\tclearTimeout(this._dragStartTimer);\n\n\t\t\t_cancelNextTick(this._cloneId);\n\t\t\t_cancelNextTick(this._dragStartId);\n\n\t\t\t// Unbind events\n\t\t\t_off(document, 'mouseover', this);\n\t\t\t_off(document, 'mousemove', this._onTouchMove);\n\n\t\t\tif (this.nativeDraggable) {\n\t\t\t\t_off(document, 'drop', this);\n\t\t\t\t_off(el, 'dragstart', this._onDragStart);\n\t\t\t}\n\n\t\t\tthis._offUpEvents();\n\n\t\t\tif (evt) {\n\t\t\t\tif (moved) {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t!options.dropBubble && evt.stopPropagation();\n\t\t\t\t}\n\n\t\t\t\tghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n\t\t\t\tif (rootEl === parentEl || Sortable.active.lastPullMode !== 'clone') {\n\t\t\t\t\t// Remove clone\n\t\t\t\t\tcloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n\t\t\t\t}\n\n\t\t\t\tif (dragEl) {\n\t\t\t\t\tif (this.nativeDraggable) {\n\t\t\t\t\t\t_off(dragEl, 'dragend', this);\n\t\t\t\t\t}\n\n\t\t\t\t\t_disableDraggable(dragEl);\n\t\t\t\t\tdragEl.style['will-change'] = '';\n\n\t\t\t\t\t// Remove class's\n\t\t\t\t\t_toggleClass(dragEl, this.options.ghostClass, false);\n\t\t\t\t\t_toggleClass(dragEl, this.options.chosenClass, false);\n\n\t\t\t\t\t// Drag stop event\n\t\t\t\t\t_dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex);\n\n\t\t\t\t\tif (rootEl !== parentEl) {\n\t\t\t\t\t\tnewIndex = _index(dragEl, options.draggable);\n\n\t\t\t\t\t\tif (newIndex >= 0) {\n\t\t\t\t\t\t\t// Add event\n\t\t\t\t\t\t\t_dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex);\n\n\t\t\t\t\t\t\t// Remove event\n\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex);\n\n\t\t\t\t\t\t\t// drag from one list and drop into another\n\t\t\t\t\t\t\t_dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dragEl.nextSibling !== nextEl) {\n\t\t\t\t\t\t\t// Get the index of the dragged element within its parent\n\t\t\t\t\t\t\tnewIndex = _index(dragEl, options.draggable);\n\n\t\t\t\t\t\t\tif (newIndex >= 0) {\n\t\t\t\t\t\t\t\t// drag & drop within the same list\n\t\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Sortable.active) {\n\t\t\t\t\t\t/* jshint eqnull:true */\n\t\t\t\t\t\tif (newIndex == null || newIndex === -1) {\n\t\t\t\t\t\t\tnewIndex = oldIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex);\n\n\t\t\t\t\t\t// Save sorting\n\t\t\t\t\t\tthis.save();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._nulling();\n\t\t},\n\n\t\t_nulling: function() {\n\t\t\trootEl =\n\t\t\tdragEl =\n\t\t\tparentEl =\n\t\t\tghostEl =\n\t\t\tnextEl =\n\t\t\tcloneEl =\n\t\t\tlastDownEl =\n\n\t\t\tscrollEl =\n\t\t\tscrollParentEl =\n\n\t\t\ttapEvt =\n\t\t\ttouchEvt =\n\n\t\t\tmoved =\n\t\t\tnewIndex =\n\n\t\t\tlastEl =\n\t\t\tlastCSS =\n\n\t\t\tputSortable =\n\t\t\tactiveGroup =\n\t\t\tSortable.active = null;\n\n\t\t\tsavedInputChecked.forEach(function (el) {\n\t\t\t\tel.checked = true;\n\t\t\t});\n\t\t\tsavedInputChecked.length = 0;\n\t\t},\n\n\t\thandleEvent: function (/**Event*/evt) {\n\t\t\tswitch (evt.type) {\n\t\t\t\tcase 'drop':\n\t\t\t\tcase 'dragend':\n\t\t\t\t\tthis._onDrop(evt);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dragover':\n\t\t\t\tcase 'dragenter':\n\t\t\t\t\tif (dragEl) {\n\t\t\t\t\t\tthis._onDragOver(evt);\n\t\t\t\t\t\t_globalDragOver(evt);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mouseover':\n\t\t\t\t\tthis._onDrop(evt);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'selectstart':\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Serializes the item into an array of string.\n\t\t * @returns {String[]}\n\t\t */\n\t\ttoArray: function () {\n\t\t\tvar order = [],\n\t\t\t\tel,\n\t\t\t\tchildren = this.el.children,\n\t\t\t\ti = 0,\n\t\t\t\tn = children.length,\n\t\t\t\toptions = this.options;\n\n\t\t\tfor (; i < n; i++) {\n\t\t\t\tel = children[i];\n\t\t\t\tif (_closest(el, options.draggable, this.el)) {\n\t\t\t\t\torder.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn order;\n\t\t},\n\n\n\t\t/**\n\t\t * Sorts the elements according to the array.\n\t\t * @param  {String[]}  order  order of the items\n\t\t */\n\t\tsort: function (order) {\n\t\t\tvar items = {}, rootEl = this.el;\n\n\t\t\tthis.toArray().forEach(function (id, i) {\n\t\t\t\tvar el = rootEl.children[i];\n\n\t\t\t\tif (_closest(el, this.options.draggable, rootEl)) {\n\t\t\t\t\titems[id] = el;\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\torder.forEach(function (id) {\n\t\t\t\tif (items[id]) {\n\t\t\t\t\trootEl.removeChild(items[id]);\n\t\t\t\t\trootEl.appendChild(items[id]);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * Save the current sorting\n\t\t */\n\t\tsave: function () {\n\t\t\tvar store = this.options.store;\n\t\t\tstore && store.set(this);\n\t\t},\n\n\n\t\t/**\n\t\t * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n\t\t * @param   {HTMLElement}  el\n\t\t * @param   {String}       [selector]  default: `options.draggable`\n\t\t * @returns {HTMLElement|null}\n\t\t */\n\t\tclosest: function (el, selector) {\n\t\t\treturn _closest(el, selector || this.options.draggable, this.el);\n\t\t},\n\n\n\t\t/**\n\t\t * Set/get option\n\t\t * @param   {string} name\n\t\t * @param   {*}      [value]\n\t\t * @returns {*}\n\t\t */\n\t\toption: function (name, value) {\n\t\t\tvar options = this.options;\n\n\t\t\tif (value === void 0) {\n\t\t\t\treturn options[name];\n\t\t\t} else {\n\t\t\t\toptions[name] = value;\n\n\t\t\t\tif (name === 'group') {\n\t\t\t\t\t_prepareGroup(options);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Destroy\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar el = this.el;\n\n\t\t\tel[expando] = null;\n\n\t\t\t_off(el, 'mousedown', this._onTapStart);\n\t\t\t_off(el, 'touchstart', this._onTapStart);\n\t\t\t_off(el, 'pointerdown', this._onTapStart);\n\n\t\t\tif (this.nativeDraggable) {\n\t\t\t\t_off(el, 'dragover', this);\n\t\t\t\t_off(el, 'dragenter', this);\n\t\t\t}\n\n\t\t\t// Remove draggable attributes\n\t\t\tArray.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n\t\t\t\tel.removeAttribute('draggable');\n\t\t\t});\n\n\t\t\ttouchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);\n\n\t\t\tthis._onDrop();\n\n\t\t\tthis.el = el = null;\n\t\t}\n\t};\n\n\n\tfunction _cloneHide(sortable, state) {\n\t\tif (sortable.lastPullMode !== 'clone') {\n\t\t\tstate = true;\n\t\t}\n\n\t\tif (cloneEl && (cloneEl.state !== state)) {\n\t\t\t_css(cloneEl, 'display', state ? 'none' : '');\n\n\t\t\tif (!state) {\n\t\t\t\tif (cloneEl.state) {\n\t\t\t\t\tif (sortable.options.group.revertClone) {\n\t\t\t\t\t\trootEl.insertBefore(cloneEl, nextEl);\n\t\t\t\t\t\tsortable._animate(dragEl, cloneEl);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEl.insertBefore(cloneEl, dragEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcloneEl.state = state;\n\t\t}\n\t}\n\n\n\tfunction _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {\n\t\tif (el) {\n\t\t\tctx = ctx || document;\n\n\t\t\tdo {\n\t\t\t\tif ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {\n\t\t\t\t\treturn el;\n\t\t\t\t}\n\t\t\t\t/* jshint boss:true */\n\t\t\t} while (el = _getParentOrHost(el));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\tfunction _getParentOrHost(el) {\n\t\tvar parent = el.host;\n\n\t\treturn (parent && parent.nodeType) ? parent : el.parentNode;\n\t}\n\n\n\tfunction _globalDragOver(/**Event*/evt) {\n\t\tif (evt.dataTransfer) {\n\t\t\tevt.dataTransfer.dropEffect = 'move';\n\t\t}\n\t\tevt.preventDefault();\n\t}\n\n\n\tfunction _on(el, event, fn) {\n\t\tel.addEventListener(event, fn, captureMode);\n\t}\n\n\n\tfunction _off(el, event, fn) {\n\t\tel.removeEventListener(event, fn, captureMode);\n\t}\n\n\n\tfunction _toggleClass(el, name, state) {\n\t\tif (el) {\n\t\t\tif (el.classList) {\n\t\t\t\tel.classList[state ? 'add' : 'remove'](name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n\t\t\t\tel.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction _css(el, prop, val) {\n\t\tvar style = el && el.style;\n\n\t\tif (style) {\n\t\t\tif (val === void 0) {\n\t\t\t\tif (document.defaultView && document.defaultView.getComputedStyle) {\n\t\t\t\t\tval = document.defaultView.getComputedStyle(el, '');\n\t\t\t\t}\n\t\t\t\telse if (el.currentStyle) {\n\t\t\t\t\tval = el.currentStyle;\n\t\t\t\t}\n\n\t\t\t\treturn prop === void 0 ? val : val[prop];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!(prop in style)) {\n\t\t\t\t\tprop = '-webkit-' + prop;\n\t\t\t\t}\n\n\t\t\t\tstyle[prop] = val + (typeof val === 'string' ? '' : 'px');\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction _find(ctx, tagName, iterator) {\n\t\tif (ctx) {\n\t\t\tvar list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;\n\n\t\t\tif (iterator) {\n\t\t\t\tfor (; i < n; i++) {\n\t\t\t\t\titerator(list[i], i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\n\n\tfunction _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex) {\n\t\tsortable = (sortable || rootEl[expando]);\n\n\t\tvar evt = document.createEvent('Event'),\n\t\t\toptions = sortable.options,\n\t\t\tonName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);\n\n\t\tevt.initEvent(name, true, true);\n\n\t\tevt.to = toEl || rootEl;\n\t\tevt.from = fromEl || rootEl;\n\t\tevt.item = targetEl || rootEl;\n\t\tevt.clone = cloneEl;\n\n\t\tevt.oldIndex = startIndex;\n\t\tevt.newIndex = newIndex;\n\n\t\trootEl.dispatchEvent(evt);\n\n\t\tif (options[onName]) {\n\t\t\toptions[onName].call(sortable, evt);\n\t\t}\n\t}\n\n\n\tfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\n\t\tvar evt,\n\t\t\tsortable = fromEl[expando],\n\t\t\tonMoveFn = sortable.options.onMove,\n\t\t\tretVal;\n\n\t\tevt = document.createEvent('Event');\n\t\tevt.initEvent('move', true, true);\n\n\t\tevt.to = toEl;\n\t\tevt.from = fromEl;\n\t\tevt.dragged = dragEl;\n\t\tevt.draggedRect = dragRect;\n\t\tevt.related = targetEl || toEl;\n\t\tevt.relatedRect = targetRect || toEl.getBoundingClientRect();\n\t\tevt.willInsertAfter = willInsertAfter;\n\n\t\tfromEl.dispatchEvent(evt);\n\n\t\tif (onMoveFn) {\n\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\n\tfunction _disableDraggable(el) {\n\t\tel.draggable = false;\n\t}\n\n\n\tfunction _unsilent() {\n\t\t_silent = false;\n\t}\n\n\n\t/** @returns {HTMLElement|false} */\n\tfunction _ghostIsLast(el, evt) {\n\t\tvar lastEl = el.lastElementChild,\n\t\t\trect = lastEl.getBoundingClientRect();\n\n\t\t// 5 — min delta\n\t\t// abs — нельзя добавлять, а то глюки при наведении сверху\n\t\treturn (evt.clientY - (rect.top + rect.height) > 5) ||\n\t\t\t(evt.clientX - (rect.left + rect.width) > 5);\n\t}\n\n\n\t/**\n\t * Generate id\n\t * @param   {HTMLElement} el\n\t * @returns {String}\n\t * @private\n\t */\n\tfunction _generateId(el) {\n\t\tvar str = el.tagName + el.className + el.src + el.href + el.textContent,\n\t\t\ti = str.length,\n\t\t\tsum = 0;\n\n\t\twhile (i--) {\n\t\t\tsum += str.charCodeAt(i);\n\t\t}\n\n\t\treturn sum.toString(36);\n\t}\n\n\t/**\n\t * Returns the index of an element within its parent for a selected set of\n\t * elements\n\t * @param  {HTMLElement} el\n\t * @param  {selector} selector\n\t * @return {number}\n\t */\n\tfunction _index(el, selector) {\n\t\tvar index = 0;\n\n\t\tif (!el || !el.parentNode) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (el && (el = el.previousElementSibling)) {\n\t\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfunction _matches(/**HTMLElement*/el, /**String*/selector) {\n\t\tif (el) {\n\t\t\tselector = selector.split('.');\n\n\t\t\tvar tag = selector.shift().toUpperCase(),\n\t\t\t\tre = new RegExp('\\\\s(' + selector.join('|') + ')(?=\\\\s)', 'g');\n\n\t\t\treturn (\n\t\t\t\t(tag === '' || el.nodeName.toUpperCase() == tag) &&\n\t\t\t\t(!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)\n\t\t\t);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction _throttle(callback, ms) {\n\t\tvar args, _this;\n\n\t\treturn function () {\n\t\t\tif (args === void 0) {\n\t\t\t\targs = arguments;\n\t\t\t\t_this = this;\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (args.length === 1) {\n\t\t\t\t\t\tcallback.call(_this, args[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback.apply(_this, args);\n\t\t\t\t\t}\n\n\t\t\t\t\targs = void 0;\n\t\t\t\t}, ms);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction _extend(dst, src) {\n\t\tif (dst && src) {\n\t\t\tfor (var key in src) {\n\t\t\t\tif (src.hasOwnProperty(key)) {\n\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dst;\n\t}\n\n\tfunction _clone(el) {\n\t\tif (Polymer && Polymer.dom) {\n\t\t\treturn Polymer.dom(el).cloneNode(true);\n\t\t}\n\t\telse if ($) {\n\t\t\treturn $(el).clone(true)[0];\n\t\t}\n\t\telse {\n\t\t\treturn el.cloneNode(true);\n\t\t}\n\t}\n\n\tfunction _saveInputCheckedState(root) {\n\t\tvar inputs = root.getElementsByTagName('input');\n\t\tvar idx = inputs.length;\n\n\t\twhile (idx--) {\n\t\t\tvar el = inputs[idx];\n\t\t\tel.checked && savedInputChecked.push(el);\n\t\t}\n\t}\n\n\tfunction _nextTick(fn) {\n\t\treturn setTimeout(fn, 0);\n\t}\n\n\tfunction _cancelNextTick(id) {\n\t\treturn clearTimeout(id);\n\t}\n\n\t// Fixed #973:\n\t_on(document, 'touchmove', function (evt) {\n\t\tif (Sortable.active) {\n\t\t\tevt.preventDefault();\n\t\t}\n\t});\n\n\t// Export utils\n\tSortable.utils = {\n\t\ton: _on,\n\t\toff: _off,\n\t\tcss: _css,\n\t\tfind: _find,\n\t\tis: function (el, selector) {\n\t\t\treturn !!_closest(el, selector, el);\n\t\t},\n\t\textend: _extend,\n\t\tthrottle: _throttle,\n\t\tclosest: _closest,\n\t\ttoggleClass: _toggleClass,\n\t\tclone: _clone,\n\t\tindex: _index,\n\t\tnextTick: _nextTick,\n\t\tcancelNextTick: _cancelNextTick\n\t};\n\n\n\t/**\n\t * Create sortable instance\n\t * @param {HTMLElement}  el\n\t * @param {Object}      [options]\n\t */\n\tSortable.create = function (el, options) {\n\t\treturn new Sortable(el, options);\n\t};\n\n\n\t// Export\n\tSortable.version = '1.7.0';\n\treturn Sortable;\n});\n\n\n//# sourceURL=webpack:///./node_modules/sortablejs/Sortable.js?")},"./source/js/main.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/Sortable.js");\n/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sortablejs__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nsortablejs__WEBPACK_IMPORTED_MODULE_0___default.a.create(todo, {\r\n    animation: 200,\r\n    group: {\r\n        name: "shared",\r\n        //pull: "clone",\r\n        revertClone: true,\r\n    },\r\n    sort: true\r\n});\r\n\r\nsortablejs__WEBPACK_IMPORTED_MODULE_0___default.a.create(completed, {\r\n    group: "shared",\r\n    sort: false\r\n});\r\n\r\n\r\n// Remove and complete icons in SVG format\r\nconst changeSVG = \'<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 64 64" style="enable-background:new 0 0 64 64;" xml:space="preserve"><g><g><path d="M33,2c7.746,0,15.028,3.017,20.505,8.494c10.138,10.137,11.31,26.396,2.74,37.849L52,52.589V44h-2v11l1,1h11v-2h-8.582l4.292-4.293l0.092-0.106c9.211-12.247,7.972-29.667-2.883-40.521C49.064,3.225,41.28,0,33,0V2z"/><path d="M7.755,15.657L12,11.411V20h2V9l-1-1H2v2h8.582L6.29,14.293l-0.092,0.106C-3.013,26.646-1.773,44.066,9.081,54.92C14.936,60.775,22.72,64,31,64v-2c-7.746,0-15.028-3.017-20.505-8.494C0.357,43.369-0.814,27.11,7.755,15.657z"/></g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>\';\r\nconst removeSVG = \'<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 22 22" style="enable-background:new 0 0 22 22;" xml:space="preserve"><g><g><path class="fill" d="M16.1,3.6h-1.9V3.3c0-1.3-1-2.3-2.3-2.3h-1.7C8.9,1,7.8,2,7.8,3.3v0.2H5.9c-1.3,0-2.3,1-2.3,2.3v1.3c0,0.5,0.4,0.9,0.9,1v10.5c0,1.3,1,2.3,2.3,2.3h8.5c1.3,0,2.3-1,2.3-2.3V8.2c0.5-0.1,0.9-0.5,0.9-1V5.9C18.4,4.6,17.4,3.6,16.1,3.6z M9.1,3.3c0-0.6,0.5-1.1,1.1-1.1h1.7c0.6,0,1.1,0.5,1.1,1.1v0.2H9.1V3.3z M16.3,18.7c0,0.6-0.5,1.1-1.1,1.1H6.7c-0.6,0-1.1-0.5-1.1-1.1V8.2h10.6L16.3,18.7L16.3,18.7z M17.2,7H4.8V5.9c0-0.6,0.5-1.1,1.1-1.1h10.2c0.6,0,1.1,0.5,1.1,1.1V7z"/></g><g><g><path class="fill" d="M11,18c-0.4,0-0.6-0.3-0.6-0.6v-6.8c0-0.4,0.3-0.6,0.6-0.6s0.6,0.3,0.6,0.6v6.8C11.6,17.7,11.4,18,11,18z"/></g><g><path class="fill" d="M8,18c-0.4,0-0.6-0.3-0.6-0.6v-6.8C7.4,10.2,7.7,10,8,10c0.4,0,0.6,0.3,0.6,0.6v6.8C8.7,17.7,8.4,18,8,18z"/></g><g><path class="fill" d="M14,18c-0.4,0-0.6-0.3-0.6-0.6v-6.8c0-0.4,0.3-0.6,0.6-0.6c0.4,0,0.6,0.3,0.6,0.6v6.8C14.6,17.7,14.3,18,14,18z"/></g></g></g></svg>\';\r\nconst completeSVG = \'<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 22 22" style="enable-background:new 0 0 22 22;" xml:space="preserve"><rect y="0" class="noFill" width="22" height="22"/><g><path class="fill" d="M9.7,14.4L9.7,14.4c-0.2,0-0.4-0.1-0.5-0.2l-2.7-2.7c-0.3-0.3-0.3-0.8,0-1.1s0.8-0.3,1.1,0l2.1,2.1l4.8-4.8c0.3-0.3,0.8-0.3,1.1,0s0.3,0.8,0,1.1l-5.3,5.3C10.1,14.3,9.9,14.4,9.7,14.4z"/></g></svg>\';\r\n\r\n\r\n// User clicked on the add button\r\n// If there is any text inside the item field, add that text to the todo list\r\ndocument.getElementById(\'add\').addEventListener(\'click\', function() {\r\n    let value = document.getElementById(\'item\').value;\r\n    if (value) {\r\n        addItemTodo(value);\r\n        document.getElementById(\'item\').value = \'\';\r\n    }\r\n});\r\n\r\ndocument.getElementById(\'item\').addEventListener(\'keydown\', function(event) {\r\n    let value = event.currentTarget.value;\r\n\r\n    if ((event.code === \'Enter\' || event.code === \'NumpadEnter\') && value) {\r\n        addItemTodo(value);\r\n        document.getElementById(\'item\').value = \'\';\r\n    }\r\n});\r\n\r\n\r\n\r\n\r\nconst changeItem = (event) => {\r\n    let item = event.currentTarget.parentNode.parentNode.childNodes[0];\r\n    let itemChange = event.currentTarget;\r\n    console.log(item);\r\n\r\n    if (item.disabled == true) {\r\n        item.removeAttribute(\'disabled\');\r\n        item.style.cursor = \'text\';\r\n        item.style.border = \'1px solid #25b99a\';\r\n        item.focus();\r\n\r\n    } else {\r\n        item.setAttribute(\'disabled\', true);\r\n        item.style.cursor = \'move\';\r\n        item.style.border = \'1px solid #838485\';\r\n    }\r\n}\r\n\r\nconst removeItem = (event) => {\r\n    let item = event.currentTarget.parentNode.parentNode;\r\n    let parent = item.parentNode;\r\n\r\n    parent.removeChild(item);\r\n}\r\n\r\nconst completeItem = (event) => {\r\n    let item = event.currentTarget.parentNode.parentNode;\r\n    let parent = item.parentNode;\r\n    let id = parent.id;\r\n    let value = item.innerText;\r\n\r\n    //===== Check if the item should be added to the completed list or to re-added to the todo list\r\n    let target = (id === \'todo\') ? document.getElementById(\'completed\') : document.getElementById(\'todo\');\r\n\r\n    parent.removeChild(item);\r\n    target.insertBefore(item, target.childNodes[0]);\r\n}\r\n\r\n//===== Adds a new item to the to do list\r\n\r\nconst addItemTodo = (text) => {\r\n    let list = document.getElementById(\'todo\');\r\n    let item = document.createElement(\'li\');\r\n    item.setAttribute("draggable", true);\r\n\r\n    let itemInput = document.createElement(\'input\');\r\n    itemInput.setAttribute("disabled", "true");\r\n    itemInput.style.cursor = \'move\';\r\n    itemInput.style.border = \'1px solid #838485\';\r\n    itemInput.value = text;\r\n\r\n    let buttons = document.createElement(\'div\');\r\n    buttons.classList.add(\'buttons\');\r\n\r\n    let change = document.createElement(\'button\');\r\n    change.classList.add(\'change\');\r\n    change.innerHTML = changeSVG;\r\n\r\n    let remove = document.createElement(\'button\');\r\n    remove.classList.add(\'remove\');\r\n    remove.innerHTML = removeSVG;\r\n\r\n    let complete = document.createElement(\'button\');\r\n    complete.classList.add(\'complete\');\r\n    complete.innerHTML = completeSVG;\r\n\r\n    //===== Add click event for changing & removing & compliting items\r\n    change.addEventListener(\'click\', changeItem);\r\n    remove.addEventListener(\'click\', removeItem);\r\n    complete.addEventListener(\'click\', completeItem);\r\n\r\n    //===== appendChild\r\n\r\n    buttons.appendChild(change);\r\n    buttons.appendChild(remove);\r\n    buttons.appendChild(complete);\r\n    item.appendChild(itemInput);\r\n    item.appendChild(buttons);\r\n    list.insertBefore(item, list.childNodes[0]);\r\n}\n\n//# sourceURL=webpack:///./source/js/main.js?')}});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJ1bmRsZS5qcyJdLCJuYW1lcyI6WyJtb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaW5zdGFsbGVkTW9kdWxlcyIsImV4cG9ydHMiLCJtb2R1bGUiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIi4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvU29ydGFibGUuanMiLCJldmFsIiwiLi9zb3VyY2UvanMvbWFpbi5qcyIsIl9fd2VicGFja19leHBvcnRzX18iXSwibWFwcGluZ3MiOiJDQUFBLFNBQUFBLEdBS0EsU0FBQUMsRUFBQUMsR0FHQSxHQUFBQyxFQUFBRCxHQUNBLE9BQUFDLEVBQUFELEdBQUFFLFFBR0EsSUFBQUMsRUFBQUYsRUFBQUQsSUFDQUksRUFBQUosRUFDQUssR0FBQSxFQUNBSCxZQVVBLE9BTkFKLEVBQUFFLEdBQUFNLEtBQUFILEVBQUFELFFBQUFDLEVBQUFBLEVBQUFELFFBQUFILEdBR0FJLEVBQUFFLEdBQUEsRUFHQUYsRUFBQUQsUUF2QkEsSUFBQUQsS0E0QkFGLEVBQUFRLEVBQUFULEVBR0FDLEVBQUFTLEVBQUFQLEVBR0FGLEVBQUFVLEVBQUEsU0FBQVAsRUFBQVEsRUFBQUMsR0FDQVosRUFBQWEsRUFBQVYsRUFBQVEsSUFDQUcsT0FBQUMsZUFBQVosRUFBQVEsR0FBQUssWUFBQSxFQUFBQyxJQUFBTCxLQUtBWixFQUFBa0IsRUFBQSxTQUFBZixHQUNBLG9CQUFBZ0IsUUFBQUEsT0FBQUMsYUFDQU4sT0FBQUMsZUFBQVosRUFBQWdCLE9BQUFDLGFBQUFDLE1BQUEsV0FFQVAsT0FBQUMsZUFBQVosRUFBQSxjQUFBa0IsT0FBQSxLQVFBckIsRUFBQXNCLEVBQUEsU0FBQUQsRUFBQUUsR0FFQSxHQURBLEVBQUFBLElBQUFGLEVBQUFyQixFQUFBcUIsSUFDQSxFQUFBRSxFQUFBLE9BQUFGLEVBQ0EsR0FBQSxFQUFBRSxHQUFBLGlCQUFBRixHQUFBQSxHQUFBQSxFQUFBRyxXQUFBLE9BQUFILEVBQ0EsSUFBQUksRUFBQVgsT0FBQVksT0FBQSxNQUdBLEdBRkExQixFQUFBa0IsRUFBQU8sR0FDQVgsT0FBQUMsZUFBQVUsRUFBQSxXQUFBVCxZQUFBLEVBQUFLLE1BQUFBLElBQ0EsRUFBQUUsR0FBQSxpQkFBQUYsRUFBQSxJQUFBLElBQUFNLEtBQUFOLEVBQUFyQixFQUFBVSxFQUFBZSxFQUFBRSxFQUFBLFNBQUFBLEdBQUEsT0FBQU4sRUFBQU0sSUFBQUMsS0FBQSxLQUFBRCxJQUNBLE9BQUFGLEdBSUF6QixFQUFBNkIsRUFBQSxTQUFBekIsR0FDQSxJQUFBUSxFQUFBUixHQUFBQSxFQUFBb0IsV0FDQSxXQUFBLE9BQUFwQixFQUFBLFNBQ0EsV0FBQSxPQUFBQSxHQUVBLE9BREFKLEVBQUFVLEVBQUFFLEVBQUEsSUFBQUEsR0FDQUEsR0FJQVosRUFBQWEsRUFBQSxTQUFBaUIsRUFBQUMsR0FBQSxPQUFBakIsT0FBQWtCLFVBQUFDLGVBQUExQixLQUFBdUIsRUFBQUMsSUFHQS9CLEVBQUFrQyxFQUFBLEdBSUFsQyxFQUFBQSxFQUFBbUMsRUFBQSx1QkFuRkEsRUF3RkFDLHdDQUtBLFNBQUFoQyxPQUFBRCxRQUFBSCxxQkFFQXFDLEtBQUEsdW4wQ0FJQUMsc0JBS0EsU0FBQWxDLE9BQUFtQyxvQkFBQXZDLHFCQUVBLGFBQ0FxQyxLQUFBIiwiZmlsZSI6Im1haW4ubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc291cmNlL2pzL21haW4uanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc29ydGFibGVqcy9Tb3J0YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvU29ydGFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyoqIVxcbiAqIFNvcnRhYmxlXFxuICogQGF1dGhvclxcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxcbiAqIEBsaWNlbnNlIE1JVFxcbiAqL1xcblxcbihmdW5jdGlvbiBzb3J0YWJsZU1vZHVsZShmYWN0b3J5KSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpIDpcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG5cXHR9XFxuXFx0ZWxzZSB7fVxcbn0pKGZ1bmN0aW9uIHNvcnRhYmxlRmFjdG9yeSgpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICF3aW5kb3cuZG9jdW1lbnQpIHtcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gc29ydGFibGVFcnJvcigpIHtcXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcIlNvcnRhYmxlLmpzIHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFxcXCIpO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdHZhciBkcmFnRWwsXFxuXFx0XFx0cGFyZW50RWwsXFxuXFx0XFx0Z2hvc3RFbCxcXG5cXHRcXHRjbG9uZUVsLFxcblxcdFxcdHJvb3RFbCxcXG5cXHRcXHRuZXh0RWwsXFxuXFx0XFx0bGFzdERvd25FbCxcXG5cXG5cXHRcXHRzY3JvbGxFbCxcXG5cXHRcXHRzY3JvbGxQYXJlbnRFbCxcXG5cXHRcXHRzY3JvbGxDdXN0b21GbixcXG5cXG5cXHRcXHRsYXN0RWwsXFxuXFx0XFx0bGFzdENTUyxcXG5cXHRcXHRsYXN0UGFyZW50Q1NTLFxcblxcblxcdFxcdG9sZEluZGV4LFxcblxcdFxcdG5ld0luZGV4LFxcblxcblxcdFxcdGFjdGl2ZUdyb3VwLFxcblxcdFxcdHB1dFNvcnRhYmxlLFxcblxcblxcdFxcdGF1dG9TY3JvbGwgPSB7fSxcXG5cXG5cXHRcXHR0YXBFdnQsXFxuXFx0XFx0dG91Y2hFdnQsXFxuXFxuXFx0XFx0bW92ZWQsXFxuXFxuXFx0XFx0LyoqIEBjb25zdCAqL1xcblxcdFxcdFJfU1BBQ0UgPSAvXFxcXHMrL2csXFxuXFx0XFx0Ul9GTE9BVCA9IC9sZWZ0fHJpZ2h0fGlubGluZS8sXFxuXFxuXFx0XFx0ZXhwYW5kbyA9ICdTb3J0YWJsZScgKyAobmV3IERhdGUpLmdldFRpbWUoKSxcXG5cXG5cXHRcXHR3aW4gPSB3aW5kb3csXFxuXFx0XFx0ZG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQsXFxuXFx0XFx0cGFyc2VJbnQgPSB3aW4ucGFyc2VJbnQsXFxuXFx0XFx0c2V0VGltZW91dCA9IHdpbi5zZXRUaW1lb3V0LFxcblxcblxcdFxcdCQgPSB3aW4ualF1ZXJ5IHx8IHdpbi5aZXB0byxcXG5cXHRcXHRQb2x5bWVyID0gd2luLlBvbHltZXIsXFxuXFxuXFx0XFx0Y2FwdHVyZU1vZGUgPSBmYWxzZSxcXG5cXHRcXHRwYXNzaXZlTW9kZSA9IGZhbHNlLFxcblxcblxcdFxcdHN1cHBvcnREcmFnZ2FibGUgPSAoJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpLFxcblxcdFxcdHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gKGZ1bmN0aW9uIChlbCkge1xcblxcdFxcdFxcdC8vIGZhbHNlIHdoZW4gSUUxMVxcblxcdFxcdFxcdGlmICghIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcXFwufG1zaWUpL2kpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcXG5cXHRcXHRcXHRlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xcblxcdFxcdFxcdHJldHVybiBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID09PSAnYXV0byc7XFxuXFx0XFx0fSkoKSxcXG5cXG5cXHRcXHRfc2lsZW50ID0gZmFsc2UsXFxuXFxuXFx0XFx0YWJzID0gTWF0aC5hYnMsXFxuXFx0XFx0bWluID0gTWF0aC5taW4sXFxuXFxuXFx0XFx0c2F2ZWRJbnB1dENoZWNrZWQgPSBbXSxcXG5cXHRcXHR0b3VjaERyYWdPdmVyTGlzdGVuZXJzID0gW10sXFxuXFxuXFx0XFx0X2F1dG9TY3JvbGwgPSBfdGhyb3R0bGUoZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQsIC8qKk9iamVjdCovb3B0aW9ucywgLyoqSFRNTEVsZW1lbnQqL3Jvb3RFbCkge1xcblxcdFxcdFxcdC8vIEJ1ZzogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTA1NTIxXFxuXFx0XFx0XFx0aWYgKHJvb3RFbCAmJiBvcHRpb25zLnNjcm9sbCkge1xcblxcdFxcdFxcdFxcdHZhciBfdGhpcyA9IHJvb3RFbFtleHBhbmRvXSxcXG5cXHRcXHRcXHRcXHRcXHRlbCxcXG5cXHRcXHRcXHRcXHRcXHRyZWN0LFxcblxcdFxcdFxcdFxcdFxcdHNlbnMgPSBvcHRpb25zLnNjcm9sbFNlbnNpdGl2aXR5LFxcblxcdFxcdFxcdFxcdFxcdHNwZWVkID0gb3B0aW9ucy5zY3JvbGxTcGVlZCxcXG5cXG5cXHRcXHRcXHRcXHRcXHR4ID0gZXZ0LmNsaWVudFgsXFxuXFx0XFx0XFx0XFx0XFx0eSA9IGV2dC5jbGllbnRZLFxcblxcblxcdFxcdFxcdFxcdFxcdHdpbldpZHRoID0gd2luZG93LmlubmVyV2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0d2luSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0LFxcblxcblxcdFxcdFxcdFxcdFxcdHZ4LFxcblxcdFxcdFxcdFxcdFxcdHZ5LFxcblxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbE9mZnNldFgsXFxuXFx0XFx0XFx0XFx0XFx0c2Nyb2xsT2Zmc2V0WVxcblxcdFxcdFxcdFxcdDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZWxlY3Qgc2Nyb2xsRWxcXG5cXHRcXHRcXHRcXHRpZiAoc2Nyb2xsUGFyZW50RWwgIT09IHJvb3RFbCkge1xcblxcdFxcdFxcdFxcdFxcdHNjcm9sbEVsID0gb3B0aW9ucy5zY3JvbGw7XFxuXFx0XFx0XFx0XFx0XFx0c2Nyb2xsUGFyZW50RWwgPSByb290RWw7XFxuXFx0XFx0XFx0XFx0XFx0c2Nyb2xsQ3VzdG9tRm4gPSBvcHRpb25zLnNjcm9sbEZuO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbEVsID0gcm9vdEVsO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoKHNjcm9sbEVsLm9mZnNldFdpZHRoIDwgc2Nyb2xsRWwuc2Nyb2xsV2lkdGgpIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KHNjcm9sbEVsLm9mZnNldEhlaWdodCA8IHNjcm9sbEVsLnNjcm9sbEhlaWdodClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0LyoganNoaW50IGJvc3M6dHJ1ZSAqL1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKHNjcm9sbEVsID0gc2Nyb2xsRWwucGFyZW50Tm9kZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoc2Nyb2xsRWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRlbCA9IHNjcm9sbEVsO1xcblxcdFxcdFxcdFxcdFxcdHJlY3QgPSBzY3JvbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXHRcXHRcXHRcXHRcXHR2eCA9IChhYnMocmVjdC5yaWdodCAtIHgpIDw9IHNlbnMpIC0gKGFicyhyZWN0LmxlZnQgLSB4KSA8PSBzZW5zKTtcXG5cXHRcXHRcXHRcXHRcXHR2eSA9IChhYnMocmVjdC5ib3R0b20gLSB5KSA8PSBzZW5zKSAtIChhYnMocmVjdC50b3AgLSB5KSA8PSBzZW5zKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCEodnggfHwgdnkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dnggPSAod2luV2lkdGggLSB4IDw9IHNlbnMpIC0gKHggPD0gc2Vucyk7XFxuXFx0XFx0XFx0XFx0XFx0dnkgPSAod2luSGVpZ2h0IC0geSA8PSBzZW5zKSAtICh5IDw9IHNlbnMpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8qIGpzaGludCBleHByOnRydWUgKi9cXG5cXHRcXHRcXHRcXHRcXHQodnggfHwgdnkpICYmIChlbCA9IHdpbik7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdFxcdGlmIChhdXRvU2Nyb2xsLnZ4ICE9PSB2eCB8fCBhdXRvU2Nyb2xsLnZ5ICE9PSB2eSB8fCBhdXRvU2Nyb2xsLmVsICE9PSBlbCkge1xcblxcdFxcdFxcdFxcdFxcdGF1dG9TY3JvbGwuZWwgPSBlbDtcXG5cXHRcXHRcXHRcXHRcXHRhdXRvU2Nyb2xsLnZ4ID0gdng7XFxuXFx0XFx0XFx0XFx0XFx0YXV0b1Njcm9sbC52eSA9IHZ5O1xcblxcblxcdFxcdFxcdFxcdFxcdGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbC5waWQpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChlbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGF1dG9TY3JvbGwucGlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbE9mZnNldFkgPSB2eSA/IHZ5ICogc3BlZWQgOiAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbE9mZnNldFggPSB2eCA/IHZ4ICogc3BlZWQgOiAwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Yoc2Nyb2xsQ3VzdG9tRm4pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjcm9sbEN1c3RvbUZuLmNhbGwoX3RoaXMsIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChlbCA9PT0gd2luKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2luLnNjcm9sbFRvKHdpbi5wYWdlWE9mZnNldCArIHNjcm9sbE9mZnNldFgsIHdpbi5wYWdlWU9mZnNldCArIHNjcm9sbE9mZnNldFkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWwuc2Nyb2xsVG9wICs9IHNjcm9sbE9mZnNldFk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWwuc2Nyb2xsTGVmdCArPSBzY3JvbGxPZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9LCAyNCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgMzApLFxcblxcblxcdFxcdF9wcmVwYXJlR3JvdXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcblxcdFxcdFxcdGZ1bmN0aW9uIHRvRm4odmFsdWUsIHB1bGwpIHtcXG5cXHRcXHRcXHRcXHRpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gZ3JvdXAubmFtZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZnJvbUdyb3VwID0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHB1bGxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ/IHZhbHVlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0OiB2YWx1ZSAmJiAodmFsdWUuam9pblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdD8gdmFsdWUuaW5kZXhPZihmcm9tR3JvdXApID4gLTFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ6IChmcm9tR3JvdXAgPT0gdmFsdWUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGdyb3VwID0ge307XFxuXFx0XFx0XFx0dmFyIG9yaWdpbmFsR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xcblxcblxcdFxcdFxcdGlmICghb3JpZ2luYWxHcm91cCB8fCB0eXBlb2Ygb3JpZ2luYWxHcm91cCAhPSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdG9yaWdpbmFsR3JvdXAgPSB7bmFtZTogb3JpZ2luYWxHcm91cH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGdyb3VwLm5hbWUgPSBvcmlnaW5hbEdyb3VwLm5hbWU7XFxuXFx0XFx0XFx0Z3JvdXAuY2hlY2tQdWxsID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1bGwsIHRydWUpO1xcblxcdFxcdFxcdGdyb3VwLmNoZWNrUHV0ID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1dCk7XFxuXFx0XFx0XFx0Z3JvdXAucmV2ZXJ0Q2xvbmUgPSBvcmlnaW5hbEdyb3VwLnJldmVydENsb25lO1xcblxcblxcdFxcdFxcdG9wdGlvbnMuZ3JvdXAgPSBncm91cDtcXG5cXHRcXHR9XFxuXFx0O1xcblxcblxcdC8vIERldGVjdCBzdXBwb3J0IGEgcGFzc2l2ZSBtb2RlXFxuXFx0dHJ5IHtcXG5cXHRcXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gYGZhbHNlYCwgYmVjYXVzZSBldmVyeXRoaW5nIHN0YXJ0cyB0byB3b3JrIGluY29ycmVjdGx5IGFuZCBpbnN0ZWFkIG9mIGQnbidkLFxcblxcdFxcdFxcdFxcdC8vIGJlZ2lucyB0aGUgcGFnZSBoYXMgc2Nyb2xsZWQuXFxuXFx0XFx0XFx0XFx0cGFzc2l2ZU1vZGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRjYXB0dXJlTW9kZSA9IHtcXG5cXHRcXHRcXHRcXHRcXHRjYXB0dXJlOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRwYXNzaXZlOiBwYXNzaXZlTW9kZVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pKTtcXG5cXHR9IGNhdGNoIChlcnIpIHt9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGNsYXNzICBTb3J0YWJsZVxcblxcdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcXG5cXHQgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zXVxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIFNvcnRhYmxlKGVsLCBvcHRpb25zKSB7XFxuXFx0XFx0aWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XFxuXFx0XFx0XFx0dGhyb3cgJ1NvcnRhYmxlOiBgZWxgIG11c3QgYmUgSFRNTEVsZW1lbnQsIGFuZCBub3QgJyArIHt9LnRvU3RyaW5nLmNhbGwoZWwpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmVsID0gZWw7IC8vIHJvb3QgZWxlbWVudFxcblxcdFxcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBfZXh0ZW5kKHt9LCBvcHRpb25zKTtcXG5cXG5cXG5cXHRcXHQvLyBFeHBvcnQgaW5zdGFuY2VcXG5cXHRcXHRlbFtleHBhbmRvXSA9IHRoaXM7XFxuXFxuXFx0XFx0Ly8gRGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dmFyIGRlZmF1bHRzID0ge1xcblxcdFxcdFxcdGdyb3VwOiBNYXRoLnJhbmRvbSgpLFxcblxcdFxcdFxcdHNvcnQ6IHRydWUsXFxuXFx0XFx0XFx0ZGlzYWJsZWQ6IGZhbHNlLFxcblxcdFxcdFxcdHN0b3JlOiBudWxsLFxcblxcdFxcdFxcdGhhbmRsZTogbnVsbCxcXG5cXHRcXHRcXHRzY3JvbGw6IHRydWUsXFxuXFx0XFx0XFx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDMwLFxcblxcdFxcdFxcdHNjcm9sbFNwZWVkOiAxMCxcXG5cXHRcXHRcXHRkcmFnZ2FibGU6IC9bdW9dbC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJ2xpJyA6ICc+KicsXFxuXFx0XFx0XFx0Z2hvc3RDbGFzczogJ3NvcnRhYmxlLWdob3N0JyxcXG5cXHRcXHRcXHRjaG9zZW5DbGFzczogJ3NvcnRhYmxlLWNob3NlbicsXFxuXFx0XFx0XFx0ZHJhZ0NsYXNzOiAnc29ydGFibGUtZHJhZycsXFxuXFx0XFx0XFx0aWdub3JlOiAnYSwgaW1nJyxcXG5cXHRcXHRcXHRmaWx0ZXI6IG51bGwsXFxuXFx0XFx0XFx0cHJldmVudE9uRmlsdGVyOiB0cnVlLFxcblxcdFxcdFxcdGFuaW1hdGlvbjogMCxcXG5cXHRcXHRcXHRzZXREYXRhOiBmdW5jdGlvbiAoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcXG5cXHRcXHRcXHRcXHRkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRyYWdFbC50ZXh0Q29udGVudCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRkcm9wQnViYmxlOiBmYWxzZSxcXG5cXHRcXHRcXHRkcmFnb3ZlckJ1YmJsZTogZmFsc2UsXFxuXFx0XFx0XFx0ZGF0YUlkQXR0cjogJ2RhdGEtaWQnLFxcblxcdFxcdFxcdGRlbGF5OiAwLFxcblxcdFxcdFxcdGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxcblxcdFxcdFxcdGZhbGxiYWNrQ2xhc3M6ICdzb3J0YWJsZS1mYWxsYmFjaycsXFxuXFx0XFx0XFx0ZmFsbGJhY2tPbkJvZHk6IGZhbHNlLFxcblxcdFxcdFxcdGZhbGxiYWNrVG9sZXJhbmNlOiAwLFxcblxcdFxcdFxcdGZhbGxiYWNrT2Zmc2V0OiB7eDogMCwgeTogMH0sXFxuXFx0XFx0XFx0c3VwcG9ydFBvaW50ZXI6IFNvcnRhYmxlLnN1cHBvcnRQb2ludGVyICE9PSBmYWxzZVxcblxcdFxcdH07XFxuXFxuXFxuXFx0XFx0Ly8gU2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcXG5cXHRcXHRcXHQhKG5hbWUgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXFxuXFx0XFx0Zm9yICh2YXIgZm4gaW4gdGhpcykge1xcblxcdFxcdFxcdGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcXG5cXHRcXHRcXHRcXHR0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXR1cCBkcmFnIG1vZGVcXG5cXHRcXHR0aGlzLm5hdGl2ZURyYWdnYWJsZSA9IG9wdGlvbnMuZm9yY2VGYWxsYmFjayA/IGZhbHNlIDogc3VwcG9ydERyYWdnYWJsZTtcXG5cXG5cXHRcXHQvLyBCaW5kIGV2ZW50c1xcblxcdFxcdF9vbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xcblxcdFxcdF9vbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcXG5cXHRcXHRvcHRpb25zLnN1cHBvcnRQb2ludGVyICYmIF9vbihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XFxuXFxuXFx0XFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0X29uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcXG5cXHRcXHRcXHRfb24oZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dG91Y2hEcmFnT3Zlckxpc3RlbmVycy5wdXNoKHRoaXMuX29uRHJhZ092ZXIpO1xcblxcblxcdFxcdC8vIFJlc3RvcmUgc29ydGluZ1xcblxcdFxcdG9wdGlvbnMuc3RvcmUgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpKTtcXG5cXHR9XFxuXFxuXFxuXFx0U29ydGFibGUucHJvdG90eXBlID0gLyoqIEBsZW5kcyBTb3J0YWJsZS5wcm90b3R5cGUgKi8ge1xcblxcdFxcdGNvbnN0cnVjdG9yOiBTb3J0YWJsZSxcXG5cXG5cXHRcXHRfb25UYXBTdGFydDogZnVuY3Rpb24gKC8qKiBFdmVudHxUb3VjaEV2ZW50ICovZXZ0KSB7XFxuXFx0XFx0XFx0dmFyIF90aGlzID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRlbCA9IHRoaXMuZWwsXFxuXFx0XFx0XFx0XFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHRcXHRwcmV2ZW50T25GaWx0ZXIgPSBvcHRpb25zLnByZXZlbnRPbkZpbHRlcixcXG5cXHRcXHRcXHRcXHR0eXBlID0gZXZ0LnR5cGUsXFxuXFx0XFx0XFx0XFx0dG91Y2ggPSBldnQudG91Y2hlcyAmJiBldnQudG91Y2hlc1swXSxcXG5cXHRcXHRcXHRcXHR0YXJnZXQgPSAodG91Y2ggfHwgZXZ0KS50YXJnZXQsXFxuXFx0XFx0XFx0XFx0b3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKGV2dC5wYXRoICYmIGV2dC5wYXRoWzBdKSB8fCB0YXJnZXQsXFxuXFx0XFx0XFx0XFx0ZmlsdGVyID0gb3B0aW9ucy5maWx0ZXIsXFxuXFx0XFx0XFx0XFx0c3RhcnRJbmRleDtcXG5cXG5cXHRcXHRcXHRfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKGVsKTtcXG5cXG5cXG5cXHRcXHRcXHQvLyBEb24ndCB0cmlnZ2VyIHN0YXJ0IGV2ZW50IHdoZW4gYW4gZWxlbWVudCBpcyBiZWVuIGRyYWdnZWQsIG90aGVyd2lzZSB0aGUgZXZ0Lm9sZGluZGV4IGFsd2F5cyB3cm9uZyB3aGVuIHNldCBvcHRpb24uZ3JvdXAuXFxuXFx0XFx0XFx0aWYgKGRyYWdFbCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKC9tb3VzZWRvd258cG9pbnRlcmRvd24vLnRlc3QodHlwZSkgJiYgZXZ0LmJ1dHRvbiAhPT0gMCB8fCBvcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIG9yIGVuYWJsZWRcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY2FuY2VsIGRuZCBpZiBvcmlnaW5hbCB0YXJnZXQgaXMgY29udGVudCBlZGl0YWJsZVxcblxcdFxcdFxcdGlmIChvcmlnaW5hbFRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGFyZ2V0ID0gX2Nsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwpO1xcblxcblxcdFxcdFxcdGlmICghdGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAobGFzdERvd25FbCA9PT0gdGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0Ly8gSWdub3JpbmcgZHVwbGljYXRlIGBkb3duYFxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XFxuXFx0XFx0XFx0c3RhcnRJbmRleCA9IF9pbmRleCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBmaWx0ZXJcXG5cXHRcXHRcXHRpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcXG5cXHRcXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudChfdGhpcywgb3JpZ2luYWxUYXJnZXQsICdmaWx0ZXInLCB0YXJnZXQsIGVsLCBlbCwgc3RhcnRJbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0cHJldmVudE9uRmlsdGVyICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjsgLy8gY2FuY2VsIGRuZFxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZWxzZSBpZiAoZmlsdGVyKSB7XFxuXFx0XFx0XFx0XFx0ZmlsdGVyID0gZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcXG5cXHRcXHRcXHRcXHRcXHRjcml0ZXJpYSA9IF9jbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoY3JpdGVyaWEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudChfdGhpcywgY3JpdGVyaWEsICdmaWx0ZXInLCB0YXJnZXQsIGVsLCBlbCwgc3RhcnRJbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdGlmIChmaWx0ZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuOyAvLyBjYW5jZWwgZG5kXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAob3B0aW9ucy5oYW5kbGUgJiYgIV9jbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBvcHRpb25zLmhhbmRsZSwgZWwpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBQcmVwYXJlIGBkcmFnc3RhcnRgXFxuXFx0XFx0XFx0dGhpcy5fcHJlcGFyZURyYWdTdGFydChldnQsIHRvdWNoLCB0YXJnZXQsIHN0YXJ0SW5kZXgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3ByZXBhcmVEcmFnU3RhcnQ6IGZ1bmN0aW9uICgvKiogRXZlbnQgKi9ldnQsIC8qKiBUb3VjaCAqL3RvdWNoLCAvKiogSFRNTEVsZW1lbnQgKi90YXJnZXQsIC8qKiBOdW1iZXIgKi9zdGFydEluZGV4KSB7XFxuXFx0XFx0XFx0dmFyIF90aGlzID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRlbCA9IF90aGlzLmVsLFxcblxcdFxcdFxcdFxcdG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdFxcdG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxcblxcdFxcdFxcdFxcdGRyYWdTdGFydEZuO1xcblxcblxcdFxcdFxcdGlmICh0YXJnZXQgJiYgIWRyYWdFbCAmJiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSkge1xcblxcdFxcdFxcdFxcdHRhcEV2dCA9IGV2dDtcXG5cXG5cXHRcXHRcXHRcXHRyb290RWwgPSBlbDtcXG5cXHRcXHRcXHRcXHRkcmFnRWwgPSB0YXJnZXQ7XFxuXFx0XFx0XFx0XFx0cGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRcXHRuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XFxuXFx0XFx0XFx0XFx0bGFzdERvd25FbCA9IHRhcmdldDtcXG5cXHRcXHRcXHRcXHRhY3RpdmVHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XFxuXFx0XFx0XFx0XFx0b2xkSW5kZXggPSBzdGFydEluZGV4O1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX2xhc3RYID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WDtcXG5cXHRcXHRcXHRcXHR0aGlzLl9sYXN0WSA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFk7XFxuXFxuXFx0XFx0XFx0XFx0ZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XFxuXFxuXFx0XFx0XFx0XFx0ZHJhZ1N0YXJ0Rm4gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRGVsYXllZCBkcmFnIGhhcyBiZWVuIHRyaWdnZXJlZFxcblxcdFxcdFxcdFxcdFxcdC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxcblxcdFxcdFxcdFxcdFxcdF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBNYWtlIHRoZSBlbGVtZW50IGRyYWdnYWJsZVxcblxcdFxcdFxcdFxcdFxcdGRyYWdFbC5kcmFnZ2FibGUgPSBfdGhpcy5uYXRpdmVEcmFnZ2FibGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2hvc2VuIGl0ZW1cXG5cXHRcXHRcXHRcXHRcXHRfdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmNob3NlbkNsYXNzLCB0cnVlKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXFxuXFx0XFx0XFx0XFx0XFx0X3RoaXMuX3RyaWdnZXJEcmFnU3RhcnQoZXZ0LCB0b3VjaCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRHJhZyBzdGFydCBldmVudFxcblxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KF90aGlzLCByb290RWwsICdjaG9vc2UnLCBkcmFnRWwsIHJvb3RFbCwgcm9vdEVsLCBvbGRJbmRleCk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEaXNhYmxlIFxcXCJkcmFnZ2FibGVcXFwiXFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xcblxcdFxcdFxcdFxcdFxcdF9maW5kKGRyYWdFbCwgY3JpdGVyaWEudHJpbSgpLCBfZGlzYWJsZURyYWdnYWJsZSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XFxuXFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xcblxcdFxcdFxcdFxcdF9vbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcXG5cXHRcXHRcXHRcXHRfb24ob3duZXJEb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgX3RoaXMpO1xcblxcdFxcdFxcdFxcdG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgX29uKG93bmVyRG9jdW1lbnQsICdwb2ludGVyY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMuZGVsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgdXNlciBtb3ZlcyB0aGUgcG9pbnRlciBvciBsZXQgZ28gdGhlIGNsaWNrIG9yIHRvdWNoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxcblxcdFxcdFxcdFxcdFxcdC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xcblxcdFxcdFxcdFxcdFxcdF9vbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcdFxcdFxcdFxcdFxcdF9vbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcXG5cXHRcXHRcXHRcXHRcXHRfb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XFxuXFx0XFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcXG5cXHRcXHRcXHRcXHRcXHRfb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgX29uKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcblxcdFxcdFxcdFxcdFxcdF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHJhZ1N0YXJ0Rm4oKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2Rpc2FibGVEZWxheWVkRHJhZzogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xcblxcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XFxuXFx0XFx0XFx0X29mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XFxuXFx0XFx0XFx0X29mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XFxuXFx0XFx0XFx0X29mZihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3RyaWdnZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uICgvKiogRXZlbnQgKi9ldnQsIC8qKiBUb3VjaCAqL3RvdWNoKSB7XFxuXFx0XFx0XFx0dG91Y2ggPSB0b3VjaCB8fCAoZXZ0LnBvaW50ZXJUeXBlID09ICd0b3VjaCcgPyBldnQgOiBudWxsKTtcXG5cXG5cXHRcXHRcXHRpZiAodG91Y2gpIHtcXG5cXHRcXHRcXHRcXHQvLyBUb3VjaCBkZXZpY2Ugc3VwcG9ydFxcblxcdFxcdFxcdFxcdHRhcEV2dCA9IHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQ6IGRyYWdFbCxcXG5cXHRcXHRcXHRcXHRcXHRjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxcblxcdFxcdFxcdFxcdFxcdGNsaWVudFk6IHRvdWNoLmNsaWVudFlcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX29uRHJhZ1N0YXJ0KHRhcEV2dCwgJ3RvdWNoJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGVsc2UgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX29uRHJhZ1N0YXJ0KHRhcEV2dCwgdHJ1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGVsc2Uge1xcblxcdFxcdFxcdFxcdF9vbihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XFxuXFx0XFx0XFx0XFx0X29uKHJvb3RFbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGltZW91dCBuZWNjZXNzYXJ5IGZvciBJRTlcXG5cXHRcXHRcXHRcXHRcXHRfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGNhdGNoIChlcnIpIHtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAocm9vdEVsICYmIGRyYWdFbCkge1xcblxcdFxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGVmZmVjdFxcblxcdFxcdFxcdFxcdF90b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0X3RvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIGZhbHNlKTtcXG5cXG5cXHRcXHRcXHRcXHRTb3J0YWJsZS5hY3RpdmUgPSB0aGlzO1xcblxcblxcdFxcdFxcdFxcdC8vIERyYWcgc3RhcnQgZXZlbnRcXG5cXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudCh0aGlzLCByb290RWwsICdzdGFydCcsIGRyYWdFbCwgcm9vdEVsLCByb290RWwsIG9sZEluZGV4KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuX251bGxpbmcoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKHRvdWNoRXZ0KSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2xhc3RYID09PSB0b3VjaEV2dC5jbGllbnRYICYmIHRoaXMuX2xhc3RZID09PSB0b3VjaEV2dC5jbGllbnRZKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9sYXN0WCA9IHRvdWNoRXZ0LmNsaWVudFg7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbGFzdFkgPSB0b3VjaEV2dC5jbGllbnRZO1xcblxcblxcdFxcdFxcdFxcdGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJ25vbmUnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XFxuXFx0XFx0XFx0XFx0dmFyIHBhcmVudCA9IHRhcmdldDtcXG5cXHRcXHRcXHRcXHR2YXIgaSA9IHRvdWNoRHJhZ092ZXJMaXN0ZW5lcnMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdGlmICh0YXJnZXQgJiYgdGFyZ2V0LnNoYWRvd1Jvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQgPSB0YXJnZXQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudCA9IHRhcmdldDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHBhcmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocGFyZW50W2V4cGFuZG9dKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRvdWNoRHJhZ092ZXJMaXN0ZW5lcnNbaV0oe1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNsaWVudFg6IHRvdWNoRXZ0LmNsaWVudFgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2xpZW50WTogdG91Y2hFdnQuY2xpZW50WSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXQ6IHRhcmdldCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyb290RWw6IHBhcmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0ID0gcGFyZW50OyAvLyBzdG9yZSBsYXN0IGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0LyoganNoaW50IGJvc3M6dHJ1ZSAqL1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXG5cXHRcXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uICgvKipUb3VjaEV2ZW50Ki9ldnQpIHtcXG5cXHRcXHRcXHRpZiAodGFwRXZ0KSB7XFxuXFx0XFx0XFx0XFx0dmFyXFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHRcXHRcXHRmYWxsYmFja1RvbGVyYW5jZSA9IG9wdGlvbnMuZmFsbGJhY2tUb2xlcmFuY2UsXFxuXFx0XFx0XFx0XFx0XFx0ZmFsbGJhY2tPZmZzZXQgPSBvcHRpb25zLmZhbGxiYWNrT2Zmc2V0LFxcblxcdFxcdFxcdFxcdFxcdHRvdWNoID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCxcXG5cXHRcXHRcXHRcXHRcXHRkeCA9ICh0b3VjaC5jbGllbnRYIC0gdGFwRXZ0LmNsaWVudFgpICsgZmFsbGJhY2tPZmZzZXQueCxcXG5cXHRcXHRcXHRcXHRcXHRkeSA9ICh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkpICsgZmFsbGJhY2tPZmZzZXQueSxcXG5cXHRcXHRcXHRcXHRcXHR0cmFuc2xhdGUzZCA9IGV2dC50b3VjaGVzID8gJ3RyYW5zbGF0ZTNkKCcgKyBkeCArICdweCwnICsgZHkgKyAncHgsMCknIDogJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsJyArIGR5ICsgJ3B4KSc7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcXG5cXHRcXHRcXHRcXHRpZiAoIVNvcnRhYmxlLmFjdGl2ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChmYWxsYmFja1RvbGVyYW5jZSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdG1pbihhYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgZmFsbGJhY2tUb2xlcmFuY2VcXG5cXHRcXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RyYWdTdGFydGVkKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGFzIHdlbGwgYXMgY3JlYXRpbmcgdGhlIGdob3N0IGVsZW1lbnQgb24gdGhlIGRvY3VtZW50IGJvZHlcXG5cXHRcXHRcXHRcXHR0aGlzLl9hcHBlbmRHaG9zdCgpO1xcblxcblxcdFxcdFxcdFxcdG1vdmVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0b3VjaEV2dCA9IHRvdWNoO1xcblxcblxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RFbCwgJ3dlYmtpdFRyYW5zZm9ybScsIHRyYW5zbGF0ZTNkKTtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdtb3pUcmFuc2Zvcm0nLCB0cmFuc2xhdGUzZCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCB0cmFuc2xhdGUzZCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgdHJhbnNsYXRlM2QpO1xcblxcblxcdFxcdFxcdFxcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICghZ2hvc3RFbCkge1xcblxcdFxcdFxcdFxcdHZhciByZWN0ID0gZHJhZ0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxcblxcdFxcdFxcdFxcdFxcdGNzcyA9IF9jc3MoZHJhZ0VsKSxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdFxcdFxcdGdob3N0UmVjdDtcXG5cXG5cXHRcXHRcXHRcXHRnaG9zdEVsID0gZHJhZ0VsLmNsb25lTm9kZSh0cnVlKTtcXG5cXG5cXHRcXHRcXHRcXHRfdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0X3RvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0X3RvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTtcXG5cXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCAtIHBhcnNlSW50KGNzcy5tYXJnaW5Ub3AsIDEwKSk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnbGVmdCcsIHJlY3QubGVmdCAtIHBhcnNlSW50KGNzcy5tYXJnaW5MZWZ0LCAxMCkpO1xcblxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RFbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xcblxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RFbCwgJ29wYWNpdHknLCAnMC44Jyk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAncG9zaXRpb24nLCAnZml4ZWQnKTtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICd6SW5kZXgnLCAnMTAwMDAwJyk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAncG9pbnRlckV2ZW50cycsICdub25lJyk7XFxuXFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5mYWxsYmFja09uQm9keSAmJiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGdob3N0RWwpIHx8IHJvb3RFbC5hcHBlbmRDaGlsZChnaG9zdEVsKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaXhpbmcgZGltZW5zaW9ucy5cXG5cXHRcXHRcXHRcXHRnaG9zdFJlY3QgPSBnaG9zdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RFbCwgJ3dpZHRoJywgcmVjdC53aWR0aCAqIDIgLSBnaG9zdFJlY3Qud2lkdGgpO1xcblxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RFbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0ICogMiAtIGdob3N0UmVjdC5oZWlnaHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQsIC8qKmJvb2xlYW4qL3VzZUZhbGxiYWNrKSB7XFxuXFx0XFx0XFx0dmFyIF90aGlzID0gdGhpcztcXG5cXHRcXHRcXHR2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2ZlcjtcXG5cXHRcXHRcXHR2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0X3RoaXMuX29mZlVwRXZlbnRzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKGFjdGl2ZUdyb3VwLmNoZWNrUHVsbChfdGhpcywgX3RoaXMsIGRyYWdFbCwgZXZ0KSkge1xcblxcdFxcdFxcdFxcdGNsb25lRWwgPSBfY2xvbmUoZHJhZ0VsKTtcXG5cXG5cXHRcXHRcXHRcXHRjbG9uZUVsLmRyYWdnYWJsZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdGNsb25lRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcXG5cXG5cXHRcXHRcXHRcXHRfY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJ25vbmUnKTtcXG5cXHRcXHRcXHRcXHRfdG9nZ2xlQ2xhc3MoY2xvbmVFbCwgX3RoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xcblxcblxcdFxcdFxcdFxcdC8vICMxMTQzOiBJRnJhbWUgc3VwcG9ydCB3b3JrYXJvdW5kXFxuXFx0XFx0XFx0XFx0X3RoaXMuX2Nsb25lSWQgPSBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudChfdGhpcywgcm9vdEVsLCAnY2xvbmUnLCBkcmFnRWwpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRfdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0aWYgKHVzZUZhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHVzZUZhbGxiYWNrID09PSAndG91Y2gnKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gQmluZCB0b3VjaCBldmVudHNcXG5cXHRcXHRcXHRcXHRcXHRfb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBfdGhpcy5fb25Ub3VjaE1vdmUpO1xcblxcdFxcdFxcdFxcdFxcdF9vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XFxuXFx0XFx0XFx0XFx0XFx0X29uKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdF9vbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgX3RoaXMuX29uVG91Y2hNb3ZlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfb24oZG9jdW1lbnQsICdwb2ludGVydXAnLCBfdGhpcy5fb25Ecm9wKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBPbGQgYnJ3b3NlclxcblxcdFxcdFxcdFxcdFxcdF9vbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIF90aGlzLl9vblRvdWNoTW92ZSk7XFxuXFx0XFx0XFx0XFx0XFx0X29uKGRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRfdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwoX3RoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAoZGF0YVRyYW5zZmVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5zZXREYXRhICYmIG9wdGlvbnMuc2V0RGF0YS5jYWxsKF90aGlzLCBkYXRhVHJhbnNmZXIsIGRyYWdFbCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdF9vbihkb2N1bWVudCwgJ2Ryb3AnLCBfdGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gIzExNDM6INCR0YvQstCw0LXRgiDRjdC70LXQvNC10L3RgiDRgSBJRnJhbWUg0LLQvdGD0YLRgNC4INCx0LvQvtC60LjRgNGD0LXRgiBgZHJvcGAsXFxuXFx0XFx0XFx0XFx0Ly8g0L/QvtGN0YLQvtC80YMg0LXRgdC70Lgg0LLRi9C30LLQsNC70YHRjyBgbW91c2VvdmVyYCwg0LfQvdCw0YfQuNGCINC90LDQtNC+INC+0YLQvNC10L3Rj9GC0Ywg0LLQtdGB0YwgZCduJ2QuXFxuXFx0XFx0XFx0XFx0Ly8gQnJlYWtpbmcgQ2hyb21lIDYyK1xcblxcdFxcdFxcdFxcdC8vIF9vbihkb2N1bWVudCwgJ21vdXNlb3ZlcicsIF90aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHRfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfb25EcmFnT3ZlcjogZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQpIHtcXG5cXHRcXHRcXHR2YXIgZWwgPSB0aGlzLmVsLFxcblxcdFxcdFxcdFxcdHRhcmdldCxcXG5cXHRcXHRcXHRcXHRkcmFnUmVjdCxcXG5cXHRcXHRcXHRcXHR0YXJnZXRSZWN0LFxcblxcdFxcdFxcdFxcdHJldmVydCxcXG5cXHRcXHRcXHRcXHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdFxcdGdyb3VwID0gb3B0aW9ucy5ncm91cCxcXG5cXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZSA9IFNvcnRhYmxlLmFjdGl2ZSxcXG5cXHRcXHRcXHRcXHRpc093bmVyID0gKGFjdGl2ZUdyb3VwID09PSBncm91cCksXFxuXFx0XFx0XFx0XFx0aXNNb3ZpbmdCZXR3ZWVuU29ydGFibGUgPSBmYWxzZSxcXG5cXHRcXHRcXHRcXHRjYW5Tb3J0ID0gb3B0aW9ucy5zb3J0O1xcblxcblxcdFxcdFxcdGlmIChldnQucHJldmVudERlZmF1bHQgIT09IHZvaWQgMCkge1xcblxcdFxcdFxcdFxcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdCFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGRyYWdFbC5hbmltYXRlZCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bW92ZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdGlmIChhY3RpdmVTb3J0YWJsZSAmJiAhb3B0aW9ucy5kaXNhYmxlZCAmJlxcblxcdFxcdFxcdFxcdChpc093bmVyXFxuXFx0XFx0XFx0XFx0XFx0PyBjYW5Tb3J0IHx8IChyZXZlcnQgPSAhcm9vdEVsLmNvbnRhaW5zKGRyYWdFbCkpIC8vIFJldmVydGluZyBpdGVtIGludG8gdGhlIG9yaWdpbmFsIGxpc3RcXG5cXHRcXHRcXHRcXHRcXHQ6IChcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXRTb3J0YWJsZSA9PT0gdGhpcyB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQoYWN0aXZlU29ydGFibGUubGFzdFB1bGxNb2RlID0gYWN0aXZlR3JvdXAuY2hlY2tQdWxsKHRoaXMsIGFjdGl2ZVNvcnRhYmxlLCBkcmFnRWwsIGV2dCkpICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z3JvdXAuY2hlY2tQdXQodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KVxcblxcdFxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0KSAmJlxcblxcdFxcdFxcdFxcdChldnQucm9vdEVsID09PSB2b2lkIDAgfHwgZXZ0LnJvb3RFbCA9PT0gdGhpcy5lbCkgLy8gdG91Y2ggZmFsbGJhY2tcXG5cXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHQvLyBTbWFydCBhdXRvLXNjcm9sbGluZ1xcblxcdFxcdFxcdFxcdF9hdXRvU2Nyb2xsKGV2dCwgb3B0aW9ucywgdGhpcy5lbCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKF9zaWxlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRhcmdldCA9IF9jbG9zZXN0KGV2dC50YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCk7XFxuXFx0XFx0XFx0XFx0ZHJhZ1JlY3QgPSBkcmFnRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHB1dFNvcnRhYmxlICE9PSB0aGlzKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHV0U29ydGFibGUgPSB0aGlzO1xcblxcdFxcdFxcdFxcdFxcdGlzTW92aW5nQmV0d2VlblNvcnRhYmxlID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHJldmVydCkge1xcblxcdFxcdFxcdFxcdFxcdF9jbG9uZUhpZGUoYWN0aXZlU29ydGFibGUsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudEVsID0gcm9vdEVsOyAvLyBhY3R1YWxpemF0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGNsb25lRWwgfHwgbmV4dEVsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cm9vdEVsLmluc2VydEJlZm9yZShkcmFnRWwsIGNsb25lRWwgfHwgbmV4dEVsKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAoIWNhblNvcnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHRcXHRpZiAoKGVsLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgfHwgKGVsLmNoaWxkcmVuWzBdID09PSBnaG9zdEVsKSB8fFxcblxcdFxcdFxcdFxcdFxcdChlbCA9PT0gZXZ0LnRhcmdldCkgJiYgKF9naG9zdElzTGFzdChlbCwgZXZ0KSlcXG5cXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvL2Fzc2lnbiB0YXJnZXQgb25seSBpZiBjb25kaXRpb24gaXMgdHJ1ZVxcblxcdFxcdFxcdFxcdFxcdGlmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgZWwuY2hpbGRyZW5bMF0gIT09IGdob3N0RWwgJiYgZWwgPT09IGV2dC50YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXQgPSBlbC5sYXN0RWxlbWVudENoaWxkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAodGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRhcmdldC5hbmltYXRlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2Nsb25lSGlkZShhY3RpdmVTb3J0YWJsZSwgaXNPd25lcik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQpICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghZHJhZ0VsLmNvbnRhaW5zKGVsKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9hbmltYXRlKGRyYWdSZWN0LCBkcmFnRWwpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldCAmJiB0aGlzLl9hbmltYXRlKHRhcmdldFJlY3QsIHRhcmdldCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRlbHNlIGlmICh0YXJnZXQgJiYgIXRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQgIT09IGRyYWdFbCAmJiAodGFyZ2V0LnBhcmVudE5vZGVbZXhwYW5kb10gIT09IHZvaWQgMCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobGFzdEVsICE9PSB0YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0RWwgPSB0YXJnZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdENTUyA9IF9jc3ModGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0UGFyZW50Q1NTID0gX2Nzcyh0YXJnZXQucGFyZW50Tm9kZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRhcmdldFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHdpZHRoID0gdGFyZ2V0UmVjdC5yaWdodCAtIHRhcmdldFJlY3QubGVmdCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoZWlnaHQgPSB0YXJnZXRSZWN0LmJvdHRvbSAtIHRhcmdldFJlY3QudG9wLFxcblxcdFxcdFxcdFxcdFxcdFxcdGZsb2F0aW5nID0gUl9GTE9BVC50ZXN0KGxhc3RDU1MuY3NzRmxvYXQgKyBsYXN0Q1NTLmRpc3BsYXkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fHwgKGxhc3RQYXJlbnRDU1MuZGlzcGxheSA9PSAnZmxleCcgJiYgbGFzdFBhcmVudENTU1snZmxleC1kaXJlY3Rpb24nXS5pbmRleE9mKCdyb3cnKSA9PT0gMCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNXaWRlID0gKHRhcmdldC5vZmZzZXRXaWR0aCA+IGRyYWdFbC5vZmZzZXRXaWR0aCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNMb25nID0gKHRhcmdldC5vZmZzZXRIZWlnaHQgPiBkcmFnRWwub2Zmc2V0SGVpZ2h0KSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYWxmd2F5ID0gKGZsb2F0aW5nID8gKGV2dC5jbGllbnRYIC0gdGFyZ2V0UmVjdC5sZWZ0KSAvIHdpZHRoIDogKGV2dC5jbGllbnRZIC0gdGFyZ2V0UmVjdC50b3ApIC8gaGVpZ2h0KSA+IDAuNSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXh0U2libGluZyA9IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmcsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YWZ0ZXIgPSBmYWxzZVxcblxcdFxcdFxcdFxcdFxcdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZmxvYXRpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZWxUb3AgPSBkcmFnRWwub2Zmc2V0VG9wLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRnVG9wID0gdGFyZ2V0Lm9mZnNldFRvcDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWxUb3AgPT09IHRnVG9wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YWZ0ZXIgPSAodGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT09IGRyYWdFbCkgJiYgIWlzV2lkZSB8fCBoYWxmd2F5ICYmIGlzV2lkZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAodGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT09IGRyYWdFbCB8fCBkcmFnRWwucHJldmlvdXNFbGVtZW50U2libGluZyA9PT0gdGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YWZ0ZXIgPSAoZXZ0LmNsaWVudFkgLSB0YXJnZXRSZWN0LnRvcCkgLyBoZWlnaHQgPiAwLjU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhZnRlciA9IHRnVG9wID4gZWxUb3A7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIWlzTW92aW5nQmV0d2VlblNvcnRhYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWZ0ZXIgPSAobmV4dFNpYmxpbmcgIT09IGRyYWdFbCkgJiYgIWlzTG9uZyB8fCBoYWxmd2F5ICYmIGlzTG9uZztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vdmVWZWN0b3IgPSBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBhZnRlcik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1vdmVWZWN0b3IgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG1vdmVWZWN0b3IgPT09IDEgfHwgbW92ZVZlY3RvciA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhZnRlciA9IChtb3ZlVmVjdG9yID09PSAxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0X3NpbGVudCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2V0VGltZW91dChfdW5zaWxlbnQsIDMwKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRfY2xvbmVIaWRlKGFjdGl2ZVNvcnRhYmxlLCBpc093bmVyKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWRyYWdFbC5jb250YWlucyhlbCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTsgLy8gYWN0dWFsaXphdGlvblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2FuaW1hdGUoZHJhZ1JlY3QsIGRyYWdFbCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fYW5pbWF0ZSh0YXJnZXRSZWN0LCB0YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2FuaW1hdGU6IGZ1bmN0aW9uIChwcmV2UmVjdCwgdGFyZ2V0KSB7XFxuXFx0XFx0XFx0dmFyIG1zID0gdGhpcy5vcHRpb25zLmFuaW1hdGlvbjtcXG5cXG5cXHRcXHRcXHRpZiAobXMpIHtcXG5cXHRcXHRcXHRcXHR2YXIgY3VycmVudFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHByZXZSZWN0Lm5vZGVUeXBlID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJldlJlY3QgPSBwcmV2UmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0X2Nzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ25vbmUnKTtcXG5cXHRcXHRcXHRcXHRfY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgnXFxuXFx0XFx0XFx0XFx0XFx0KyAocHJldlJlY3QubGVmdCAtIGN1cnJlbnRSZWN0LmxlZnQpICsgJ3B4LCdcXG5cXHRcXHRcXHRcXHRcXHQrIChwcmV2UmVjdC50b3AgLSBjdXJyZW50UmVjdC50b3ApICsgJ3B4LDApJ1xcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0dGFyZ2V0Lm9mZnNldFdpZHRoOyAvLyByZXBhaW50XFxuXFxuXFx0XFx0XFx0XFx0X2Nzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ2FsbCAnICsgbXMgKyAnbXMnKTtcXG5cXHRcXHRcXHRcXHRfY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcXG5cXG5cXHRcXHRcXHRcXHRjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRfY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XFxuXFx0XFx0XFx0XFx0XFx0X2Nzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0LmFuaW1hdGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fSwgbXMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9vZmZVcEV2ZW50czogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xcblxcblxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XFxuXFx0XFx0XFx0X29mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbkRyb3ApO1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ecm9wKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9vbkRyb3ApO1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVyY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIHRoaXMpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X29uRHJvcDogZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQpIHtcXG5cXHRcXHRcXHR2YXIgZWwgPSB0aGlzLmVsLFxcblxcdFxcdFxcdFxcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0Y2xlYXJJbnRlcnZhbCh0aGlzLl9sb29wSWQpO1xcblxcdFxcdFxcdGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbC5waWQpO1xcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XFxuXFxuXFx0XFx0XFx0X2NhbmNlbE5leHRUaWNrKHRoaXMuX2Nsb25lSWQpO1xcblxcdFxcdFxcdF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7XFxuXFxuXFx0XFx0XFx0Ly8gVW5iaW5kIGV2ZW50c1xcblxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICdtb3VzZW92ZXInLCB0aGlzKTtcXG5cXHRcXHRcXHRfb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xcblxcdFxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XFxuXFx0XFx0XFx0XFx0X29mZihlbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fb2ZmVXBFdmVudHMoKTtcXG5cXG5cXHRcXHRcXHRpZiAoZXZ0KSB7XFxuXFx0XFx0XFx0XFx0aWYgKG1vdmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0IW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdob3N0RWwgJiYgZ2hvc3RFbC5wYXJlbnROb2RlICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBTb3J0YWJsZS5hY3RpdmUubGFzdFB1bGxNb2RlICE9PSAnY2xvbmUnKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGNsb25lXFxuXFx0XFx0XFx0XFx0XFx0Y2xvbmVFbCAmJiBjbG9uZUVsLnBhcmVudE5vZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoZHJhZ0VsKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X29mZihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGNsYXNzJ3NcXG5cXHRcXHRcXHRcXHRcXHRfdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdF90b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERyYWcgc3RvcCBldmVudFxcblxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3VuY2hvb3NlJywgZHJhZ0VsLCBwYXJlbnRFbCwgcm9vdEVsLCBvbGRJbmRleCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHJvb3RFbCAhPT0gcGFyZW50RWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdJbmRleCA9IF9pbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3SW5kZXggPj0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFkZCBldmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KG51bGwsIHBhcmVudEVsLCAnYWRkJywgZHJhZ0VsLCBwYXJlbnRFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBldmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3JlbW92ZScsIGRyYWdFbCwgcGFyZW50RWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBkcmFnIGZyb20gb25lIGxpc3QgYW5kIGRyb3AgaW50byBhbm90aGVyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2Rpc3BhdGNoRXZlbnQobnVsbCwgcGFyZW50RWwsICdzb3J0JywgZHJhZ0VsLCBwYXJlbnRFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3NvcnQnLCBkcmFnRWwsIHBhcmVudEVsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZHJhZ0VsLm5leHRTaWJsaW5nICE9PSBuZXh0RWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdJbmRleCA9IF9pbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3SW5kZXggPj0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGRyYWcgJiBkcm9wIHdpdGhpbiB0aGUgc2FtZSBsaXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X2Rpc3BhdGNoRXZlbnQodGhpcywgcm9vdEVsLCAndXBkYXRlJywgZHJhZ0VsLCBwYXJlbnRFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3NvcnQnLCBkcmFnRWwsIHBhcmVudEVsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKFNvcnRhYmxlLmFjdGl2ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8qIGpzaGludCBlcW51bGw6dHJ1ZSAqL1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChuZXdJbmRleCA9PSBudWxsIHx8IG5ld0luZGV4ID09PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0luZGV4ID0gb2xkSW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ2VuZCcsIGRyYWdFbCwgcGFyZW50RWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTYXZlIHNvcnRpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNhdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9udWxsaW5nKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbnVsbGluZzogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cm9vdEVsID1cXG5cXHRcXHRcXHRkcmFnRWwgPVxcblxcdFxcdFxcdHBhcmVudEVsID1cXG5cXHRcXHRcXHRnaG9zdEVsID1cXG5cXHRcXHRcXHRuZXh0RWwgPVxcblxcdFxcdFxcdGNsb25lRWwgPVxcblxcdFxcdFxcdGxhc3REb3duRWwgPVxcblxcblxcdFxcdFxcdHNjcm9sbEVsID1cXG5cXHRcXHRcXHRzY3JvbGxQYXJlbnRFbCA9XFxuXFxuXFx0XFx0XFx0dGFwRXZ0ID1cXG5cXHRcXHRcXHR0b3VjaEV2dCA9XFxuXFxuXFx0XFx0XFx0bW92ZWQgPVxcblxcdFxcdFxcdG5ld0luZGV4ID1cXG5cXG5cXHRcXHRcXHRsYXN0RWwgPVxcblxcdFxcdFxcdGxhc3RDU1MgPVxcblxcblxcdFxcdFxcdHB1dFNvcnRhYmxlID1cXG5cXHRcXHRcXHRhY3RpdmVHcm91cCA9XFxuXFx0XFx0XFx0U29ydGFibGUuYWN0aXZlID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRzYXZlZElucHV0Q2hlY2tlZC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xcblxcdFxcdFxcdFxcdGVsLmNoZWNrZWQgPSB0cnVlO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IDA7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQpIHtcXG5cXHRcXHRcXHRzd2l0Y2ggKGV2dC50eXBlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSAnZHJvcCc6XFxuXFx0XFx0XFx0XFx0Y2FzZSAnZHJhZ2VuZCc6XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fb25Ecm9wKGV2dCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAnZHJhZ292ZXInOlxcblxcdFxcdFxcdFxcdGNhc2UgJ2RyYWdlbnRlcic6XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRyYWdFbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfZ2xvYmFsRHJhZ092ZXIoZXZ0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAnbW91c2VvdmVyJzpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9vbkRyb3AoZXZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlICdzZWxlY3RzdGFydCc6XFxuXFx0XFx0XFx0XFx0XFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cXG5cXHRcXHQgKiBAcmV0dXJucyB7U3RyaW5nW119XFxuXFx0XFx0ICovXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBvcmRlciA9IFtdLFxcblxcdFxcdFxcdFxcdGVsLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcXG5cXHRcXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRcXHRuID0gY2hpbGRyZW4ubGVuZ3RoLFxcblxcdFxcdFxcdFxcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0Zm9yICg7IGkgPCBuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRlbCA9IGNoaWxkcmVuW2ldO1xcblxcdFxcdFxcdFxcdGlmIChfY2xvc2VzdChlbCwgb3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwpKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3JkZXIucHVzaChlbC5nZXRBdHRyaWJ1dGUob3B0aW9ucy5kYXRhSWRBdHRyKSB8fCBfZ2VuZXJhdGVJZChlbCkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9yZGVyO1xcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogU29ydHMgdGhlIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUgYXJyYXkuXFxuXFx0XFx0ICogQHBhcmFtICB7U3RyaW5nW119ICBvcmRlciAgb3JkZXIgb2YgdGhlIGl0ZW1zXFxuXFx0XFx0ICovXFxuXFx0XFx0c29ydDogZnVuY3Rpb24gKG9yZGVyKSB7XFxuXFx0XFx0XFx0dmFyIGl0ZW1zID0ge30sIHJvb3RFbCA9IHRoaXMuZWw7XFxuXFxuXFx0XFx0XFx0dGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWwgPSByb290RWwuY2hpbGRyZW5baV07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKF9jbG9zZXN0KGVsLCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCByb290RWwpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aXRlbXNbaWRdID0gZWw7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpO1xcblxcblxcdFxcdFxcdG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGl0ZW1zW2lkXSkge1xcblxcdFxcdFxcdFxcdFxcdHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xcblxcdFxcdFxcdFxcdFxcdHJvb3RFbC5hcHBlbmRDaGlsZChpdGVtc1tpZF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFNhdmUgdGhlIGN1cnJlbnQgc29ydGluZ1xcblxcdFxcdCAqL1xcblxcdFxcdHNhdmU6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgc3RvcmUgPSB0aGlzLm9wdGlvbnMuc3RvcmU7XFxuXFx0XFx0XFx0c3RvcmUgJiYgc3RvcmUuc2V0KHRoaXMpO1xcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxcblxcdFxcdCAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXFxuXFx0XFx0ICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxcblxcdFxcdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxcblxcdFxcdCAqL1xcblxcdFxcdGNsb3Nlc3Q6IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRyZXR1cm4gX2Nsb3Nlc3QoZWwsIHNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwpO1xcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogU2V0L2dldCBvcHRpb25cXG5cXHRcXHQgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXFxuXFx0XFx0ICogQHBhcmFtICAgeyp9ICAgICAgW3ZhbHVlXVxcblxcdFxcdCAqIEByZXR1cm5zIHsqfVxcblxcdFxcdCAqL1xcblxcdFxcdG9wdGlvbjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0aWYgKHZhbHVlID09PSB2b2lkIDApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gb3B0aW9uc1tuYW1lXTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAobmFtZSA9PT0gJ2dyb3VwJykge1xcblxcdFxcdFxcdFxcdFxcdF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIERlc3Ryb3lcXG5cXHRcXHQgKi9cXG5cXHRcXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dmFyIGVsID0gdGhpcy5lbDtcXG5cXG5cXHRcXHRcXHRlbFtleHBhbmRvXSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0X29mZihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xcblxcdFxcdFxcdF9vZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XFxuXFx0XFx0XFx0X29mZihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0X29mZihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XFxuXFx0XFx0XFx0XFx0X29mZihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgZHJhZ2dhYmxlIGF0dHJpYnV0ZXNcXG5cXHRcXHRcXHRBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkcmFnZ2FibGVdJyksIGZ1bmN0aW9uIChlbCkge1xcblxcdFxcdFxcdFxcdGVsLnJlbW92ZUF0dHJpYnV0ZSgnZHJhZ2dhYmxlJyk7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dG91Y2hEcmFnT3Zlckxpc3RlbmVycy5zcGxpY2UodG91Y2hEcmFnT3Zlckxpc3RlbmVycy5pbmRleE9mKHRoaXMuX29uRHJhZ092ZXIpLCAxKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9vbkRyb3AoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmVsID0gZWwgPSBudWxsO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcblxcdGZ1bmN0aW9uIF9jbG9uZUhpZGUoc29ydGFibGUsIHN0YXRlKSB7XFxuXFx0XFx0aWYgKHNvcnRhYmxlLmxhc3RQdWxsTW9kZSAhPT0gJ2Nsb25lJykge1xcblxcdFxcdFxcdHN0YXRlID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKGNsb25lRWwgJiYgKGNsb25lRWwuc3RhdGUgIT09IHN0YXRlKSkge1xcblxcdFxcdFxcdF9jc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCBzdGF0ZSA/ICdub25lJyA6ICcnKTtcXG5cXG5cXHRcXHRcXHRpZiAoIXN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGNsb25lRWwuc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc29ydGFibGUub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgbmV4dEVsKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5fYW5pbWF0ZShkcmFnRWwsIGNsb25lRWwpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNsb25lRWwuc3RhdGUgPSBzdGF0ZTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF9jbG9zZXN0KC8qKkhUTUxFbGVtZW50Ki9lbCwgLyoqU3RyaW5nKi9zZWxlY3RvciwgLyoqSFRNTEVsZW1lbnQqL2N0eCkge1xcblxcdFxcdGlmIChlbCkge1xcblxcdFxcdFxcdGN0eCA9IGN0eCB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0aWYgKChzZWxlY3RvciA9PT0gJz4qJyAmJiBlbC5wYXJlbnROb2RlID09PSBjdHgpIHx8IF9tYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWw7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qIGpzaGludCBib3NzOnRydWUgKi9cXG5cXHRcXHRcXHR9IHdoaWxlIChlbCA9IF9nZXRQYXJlbnRPckhvc3QoZWwpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF9nZXRQYXJlbnRPckhvc3QoZWwpIHtcXG5cXHRcXHR2YXIgcGFyZW50ID0gZWwuaG9zdDtcXG5cXG5cXHRcXHRyZXR1cm4gKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUpID8gcGFyZW50IDogZWwucGFyZW50Tm9kZTtcXG5cXHR9XFxuXFxuXFxuXFx0ZnVuY3Rpb24gX2dsb2JhbERyYWdPdmVyKC8qKkV2ZW50Ki9ldnQpIHtcXG5cXHRcXHRpZiAoZXZ0LmRhdGFUcmFuc2Zlcikge1xcblxcdFxcdFxcdGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcXG5cXHRcXHR9XFxuXFx0XFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF9vbihlbCwgZXZlbnQsIGZuKSB7XFxuXFx0XFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIGNhcHR1cmVNb2RlKTtcXG5cXHR9XFxuXFxuXFxuXFx0ZnVuY3Rpb24gX29mZihlbCwgZXZlbnQsIGZuKSB7XFxuXFx0XFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIGNhcHR1cmVNb2RlKTtcXG5cXHR9XFxuXFxuXFxuXFx0ZnVuY3Rpb24gX3RvZ2dsZUNsYXNzKGVsLCBuYW1lLCBzdGF0ZSkge1xcblxcdFxcdGlmIChlbCkge1xcblxcdFxcdFxcdGlmIChlbC5jbGFzc0xpc3QpIHtcXG5cXHRcXHRcXHRcXHRlbC5jbGFzc0xpc3Rbc3RhdGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XFxuXFx0XFx0XFx0XFx0ZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXG5cXHRmdW5jdGlvbiBfY3NzKGVsLCBwcm9wLCB2YWwpIHtcXG5cXHRcXHR2YXIgc3R5bGUgPSBlbCAmJiBlbC5zdHlsZTtcXG5cXG5cXHRcXHRpZiAoc3R5bGUpIHtcXG5cXHRcXHRcXHRpZiAodmFsID09PSB2b2lkIDApIHtcXG5cXHRcXHRcXHRcXHRpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhbCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZWxzZSBpZiAoZWwuY3VycmVudFN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsID0gZWwuY3VycmVudFN0eWxlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAoIShwcm9wIGluIHN0eWxlKSkge1xcblxcdFxcdFxcdFxcdFxcdHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF9maW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcXG5cXHRcXHRpZiAoY3R4KSB7XFxuXFx0XFx0XFx0dmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKGl0ZXJhdG9yKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICg7IGkgPCBuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVyYXRvcihsaXN0W2ldLCBpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBsaXN0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gW107XFxuXFx0fVxcblxcblxcblxcblxcdGZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KHNvcnRhYmxlLCByb290RWwsIG5hbWUsIHRhcmdldEVsLCB0b0VsLCBmcm9tRWwsIHN0YXJ0SW5kZXgsIG5ld0luZGV4KSB7XFxuXFx0XFx0c29ydGFibGUgPSAoc29ydGFibGUgfHwgcm9vdEVsW2V4cGFuZG9dKTtcXG5cXG5cXHRcXHR2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JyksXFxuXFx0XFx0XFx0b3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnMsXFxuXFx0XFx0XFx0b25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcXG5cXG5cXHRcXHRldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xcblxcblxcdFxcdGV2dC50byA9IHRvRWwgfHwgcm9vdEVsO1xcblxcdFxcdGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcXG5cXHRcXHRldnQuaXRlbSA9IHRhcmdldEVsIHx8IHJvb3RFbDtcXG5cXHRcXHRldnQuY2xvbmUgPSBjbG9uZUVsO1xcblxcblxcdFxcdGV2dC5vbGRJbmRleCA9IHN0YXJ0SW5kZXg7XFxuXFx0XFx0ZXZ0Lm5ld0luZGV4ID0gbmV3SW5kZXg7XFxuXFxuXFx0XFx0cm9vdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcXG5cXG5cXHRcXHRpZiAob3B0aW9uc1tvbk5hbWVdKSB7XFxuXFx0XFx0XFx0b3B0aW9uc1tvbk5hbWVdLmNhbGwoc29ydGFibGUsIGV2dCk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXG5cXHRmdW5jdGlvbiBfb25Nb3ZlKGZyb21FbCwgdG9FbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0RWwsIHRhcmdldFJlY3QsIG9yaWdpbmFsRXZ0LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcXG5cXHRcXHR2YXIgZXZ0LFxcblxcdFxcdFxcdHNvcnRhYmxlID0gZnJvbUVsW2V4cGFuZG9dLFxcblxcdFxcdFxcdG9uTW92ZUZuID0gc29ydGFibGUub3B0aW9ucy5vbk1vdmUsXFxuXFx0XFx0XFx0cmV0VmFsO1xcblxcblxcdFxcdGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xcblxcdFxcdGV2dC5pbml0RXZlbnQoJ21vdmUnLCB0cnVlLCB0cnVlKTtcXG5cXG5cXHRcXHRldnQudG8gPSB0b0VsO1xcblxcdFxcdGV2dC5mcm9tID0gZnJvbUVsO1xcblxcdFxcdGV2dC5kcmFnZ2VkID0gZHJhZ0VsO1xcblxcdFxcdGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xcblxcdFxcdGV2dC5yZWxhdGVkID0gdGFyZ2V0RWwgfHwgdG9FbDtcXG5cXHRcXHRldnQucmVsYXRlZFJlY3QgPSB0YXJnZXRSZWN0IHx8IHRvRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFx0XFx0ZXZ0LndpbGxJbnNlcnRBZnRlciA9IHdpbGxJbnNlcnRBZnRlcjtcXG5cXG5cXHRcXHRmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xcblxcblxcdFxcdGlmIChvbk1vdmVGbikge1xcblxcdFxcdFxcdHJldFZhbCA9IG9uTW92ZUZuLmNhbGwoc29ydGFibGUsIGV2dCwgb3JpZ2luYWxFdnQpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcmV0VmFsO1xcblxcdH1cXG5cXG5cXG5cXHRmdW5jdGlvbiBfZGlzYWJsZURyYWdnYWJsZShlbCkge1xcblxcdFxcdGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xcblxcdH1cXG5cXG5cXG5cXHRmdW5jdGlvbiBfdW5zaWxlbnQoKSB7XFxuXFx0XFx0X3NpbGVudCA9IGZhbHNlO1xcblxcdH1cXG5cXG5cXG5cXHQvKiogQHJldHVybnMge0hUTUxFbGVtZW50fGZhbHNlfSAqL1xcblxcdGZ1bmN0aW9uIF9naG9zdElzTGFzdChlbCwgZXZ0KSB7XFxuXFx0XFx0dmFyIGxhc3RFbCA9IGVsLmxhc3RFbGVtZW50Q2hpbGQsXFxuXFx0XFx0XFx0cmVjdCA9IGxhc3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXG5cXHRcXHQvLyA1IOKAlCBtaW4gZGVsdGFcXG5cXHRcXHQvLyBhYnMg4oCUINC90LXQu9GM0LfRjyDQtNC+0LHQsNCy0LvRj9GC0YwsINCwINGC0L4g0LPQu9GO0LrQuCDQv9GA0Lgg0L3QsNCy0LXQtNC10L3QuNC4INGB0LLQtdGA0YXRg1xcblxcdFxcdHJldHVybiAoZXZ0LmNsaWVudFkgLSAocmVjdC50b3AgKyByZWN0LmhlaWdodCkgPiA1KSB8fFxcblxcdFxcdFxcdChldnQuY2xpZW50WCAtIChyZWN0LmxlZnQgKyByZWN0LndpZHRoKSA+IDUpO1xcblxcdH1cXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBHZW5lcmF0ZSBpZFxcblxcdCAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxcXG5cXHQgKiBAcmV0dXJucyB7U3RyaW5nfVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0ZnVuY3Rpb24gX2dlbmVyYXRlSWQoZWwpIHtcXG5cXHRcXHR2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcXG5cXHRcXHRcXHRpID0gc3RyLmxlbmd0aCxcXG5cXHRcXHRcXHRzdW0gPSAwO1xcblxcblxcdFxcdHdoaWxlIChpLS0pIHtcXG5cXHRcXHRcXHRzdW0gKz0gc3RyLmNoYXJDb2RlQXQoaSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBzdW0udG9TdHJpbmcoMzYpO1xcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50IGZvciBhIHNlbGVjdGVkIHNldCBvZlxcblxcdCAqIGVsZW1lbnRzXFxuXFx0ICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXFxuXFx0ICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yXFxuXFx0ICogQHJldHVybiB7bnVtYmVyfVxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIF9pbmRleChlbCwgc2VsZWN0b3IpIHtcXG5cXHRcXHR2YXIgaW5kZXggPSAwO1xcblxcblxcdFxcdGlmICghZWwgfHwgIWVsLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gLTE7XFxuXFx0XFx0fVxcblxcblxcdFxcdHdoaWxlIChlbCAmJiAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSkge1xcblxcdFxcdFxcdGlmICgoZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1RFTVBMQVRFJykgJiYgKHNlbGVjdG9yID09PSAnPionIHx8IF9tYXRjaGVzKGVsLCBzZWxlY3RvcikpKSB7XFxuXFx0XFx0XFx0XFx0aW5kZXgrKztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBpbmRleDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX21hdGNoZXMoLyoqSFRNTEVsZW1lbnQqL2VsLCAvKipTdHJpbmcqL3NlbGVjdG9yKSB7XFxuXFx0XFx0aWYgKGVsKSB7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xcblxcblxcdFxcdFxcdHZhciB0YWcgPSBzZWxlY3Rvci5zaGlmdCgpLnRvVXBwZXJDYXNlKCksXFxuXFx0XFx0XFx0XFx0cmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXHMoJyArIHNlbGVjdG9yLmpvaW4oJ3wnKSArICcpKD89XFxcXFxcXFxzKScsICdnJyk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHQodGFnID09PSAnJyB8fCBlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IHRhZykgJiZcXG5cXHRcXHRcXHRcXHQoIXNlbGVjdG9yLmxlbmd0aCB8fCAoKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykubWF0Y2gocmUpIHx8IFtdKS5sZW5ndGggPT0gc2VsZWN0b3IubGVuZ3RoKVxcblxcdFxcdFxcdCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX3Rocm90dGxlKGNhbGxiYWNrLCBtcykge1xcblxcdFxcdHZhciBhcmdzLCBfdGhpcztcXG5cXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmIChhcmdzID09PSB2b2lkIDApIHtcXG5cXHRcXHRcXHRcXHRhcmdzID0gYXJndW1lbnRzO1xcblxcdFxcdFxcdFxcdF90aGlzID0gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXJncyA9IHZvaWQgMDtcXG5cXHRcXHRcXHRcXHR9LCBtcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIF9leHRlbmQoZHN0LCBzcmMpIHtcXG5cXHRcXHRpZiAoZHN0ICYmIHNyYykge1xcblxcdFxcdFxcdGZvciAodmFyIGtleSBpbiBzcmMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRkc3Rba2V5XSA9IHNyY1trZXldO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBkc3Q7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIF9jbG9uZShlbCkge1xcblxcdFxcdGlmIChQb2x5bWVyICYmIFBvbHltZXIuZG9tKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFBvbHltZXIuZG9tKGVsKS5jbG9uZU5vZGUodHJ1ZSk7XFxuXFx0XFx0fVxcblxcdFxcdGVsc2UgaWYgKCQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJChlbCkuY2xvbmUodHJ1ZSlbMF07XFxuXFx0XFx0fVxcblxcdFxcdGVsc2Uge1xcblxcdFxcdFxcdHJldHVybiBlbC5jbG9uZU5vZGUodHJ1ZSk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKHJvb3QpIHtcXG5cXHRcXHR2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcXG5cXHRcXHR2YXIgaWR4ID0gaW5wdXRzLmxlbmd0aDtcXG5cXG5cXHRcXHR3aGlsZSAoaWR4LS0pIHtcXG5cXHRcXHRcXHR2YXIgZWwgPSBpbnB1dHNbaWR4XTtcXG5cXHRcXHRcXHRlbC5jaGVja2VkICYmIHNhdmVkSW5wdXRDaGVja2VkLnB1c2goZWwpO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX25leHRUaWNrKGZuKSB7XFxuXFx0XFx0cmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcXG5cXHRcXHRyZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcXG5cXHR9XFxuXFxuXFx0Ly8gRml4ZWQgIzk3MzpcXG5cXHRfb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuXFx0XFx0aWYgKFNvcnRhYmxlLmFjdGl2ZSkge1xcblxcdFxcdFxcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQvLyBFeHBvcnQgdXRpbHNcXG5cXHRTb3J0YWJsZS51dGlscyA9IHtcXG5cXHRcXHRvbjogX29uLFxcblxcdFxcdG9mZjogX29mZixcXG5cXHRcXHRjc3M6IF9jc3MsXFxuXFx0XFx0ZmluZDogX2ZpbmQsXFxuXFx0XFx0aXM6IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRyZXR1cm4gISFfY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsKTtcXG5cXHRcXHR9LFxcblxcdFxcdGV4dGVuZDogX2V4dGVuZCxcXG5cXHRcXHR0aHJvdHRsZTogX3Rocm90dGxlLFxcblxcdFxcdGNsb3Nlc3Q6IF9jbG9zZXN0LFxcblxcdFxcdHRvZ2dsZUNsYXNzOiBfdG9nZ2xlQ2xhc3MsXFxuXFx0XFx0Y2xvbmU6IF9jbG9uZSxcXG5cXHRcXHRpbmRleDogX2luZGV4LFxcblxcdFxcdG5leHRUaWNrOiBfbmV4dFRpY2ssXFxuXFx0XFx0Y2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGlja1xcblxcdH07XFxuXFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gIGVsXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9ICAgICAgW29wdGlvbnNdXFxuXFx0ICovXFxuXFx0U29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XFxuXFx0XFx0cmV0dXJuIG5ldyBTb3J0YWJsZShlbCwgb3B0aW9ucyk7XFxuXFx0fTtcXG5cXG5cXG5cXHQvLyBFeHBvcnRcXG5cXHRTb3J0YWJsZS52ZXJzaW9uID0gJzEuNy4wJztcXG5cXHRyZXR1cm4gU29ydGFibGU7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvU29ydGFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NvdXJjZS9qcy9tYWluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zb3VyY2UvanMvbWFpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzb3J0YWJsZWpzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzb3J0YWJsZWpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zb3J0YWJsZWpzL1NvcnRhYmxlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNvcnRhYmxlanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihzb3J0YWJsZWpzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcclxcblxcclxcbnNvcnRhYmxlanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKHRvZG8sIHtcXHJcXG4gICAgYW5pbWF0aW9uOiAyMDAsXFxyXFxuICAgIGdyb3VwOiB7XFxyXFxuICAgICAgICBuYW1lOiBcXFwic2hhcmVkXFxcIixcXHJcXG4gICAgICAgIC8vcHVsbDogXFxcImNsb25lXFxcIixcXHJcXG4gICAgICAgIHJldmVydENsb25lOiB0cnVlLFxcclxcbiAgICB9LFxcclxcbiAgICBzb3J0OiB0cnVlXFxyXFxufSk7XFxyXFxuXFxyXFxuc29ydGFibGVqc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoY29tcGxldGVkLCB7XFxyXFxuICAgIGdyb3VwOiBcXFwic2hhcmVkXFxcIixcXHJcXG4gICAgc29ydDogZmFsc2VcXHJcXG59KTtcXHJcXG5cXHJcXG5cXHJcXG4vLyBSZW1vdmUgYW5kIGNvbXBsZXRlIGljb25zIGluIFNWRyBmb3JtYXRcXHJcXG5jb25zdCBjaGFuZ2VTVkcgPSAnPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJDYXBhXzFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgNjQgNjRcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDY0IDY0O1xcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCI+PGc+PGc+PHBhdGggZD1cXFwiTTMzLDJjNy43NDYsMCwxNS4wMjgsMy4wMTcsMjAuNTA1LDguNDk0YzEwLjEzOCwxMC4xMzcsMTEuMzEsMjYuMzk2LDIuNzQsMzcuODQ5TDUyLDUyLjU4OVY0NGgtMnYxMWwxLDFoMTF2LTJoLTguNTgybDQuMjkyLTQuMjkzbDAuMDkyLTAuMTA2YzkuMjExLTEyLjI0Nyw3Ljk3Mi0yOS42NjctMi44ODMtNDAuNTIxQzQ5LjA2NCwzLjIyNSw0MS4yOCwwLDMzLDBWMnpcXFwiLz48cGF0aCBkPVxcXCJNNy43NTUsMTUuNjU3TDEyLDExLjQxMVYyMGgyVjlsLTEtMUgydjJoOC41ODJMNi4yOSwxNC4yOTNsLTAuMDkyLDAuMTA2Qy0zLjAxMywyNi42NDYtMS43NzMsNDQuMDY2LDkuMDgxLDU0LjkyQzE0LjkzNiw2MC43NzUsMjIuNzIsNjQsMzEsNjR2LTJjLTcuNzQ2LDAtMTUuMDI4LTMuMDE3LTIwLjUwNS04LjQ5NEMwLjM1Nyw0My4zNjktMC44MTQsMjcuMTEsNy43NTUsMTUuNjU3elxcXCIvPjwvZz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+JztcXHJcXG5jb25zdCByZW1vdmVTVkcgPSAnPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJMYXllcl8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDIyIDIyXFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMiAyMjtcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPjxnPjxnPjxwYXRoIGNsYXNzPVxcXCJmaWxsXFxcIiBkPVxcXCJNMTYuMSwzLjZoLTEuOVYzLjNjMC0xLjMtMS0yLjMtMi4zLTIuM2gtMS43QzguOSwxLDcuOCwyLDcuOCwzLjN2MC4ySDUuOWMtMS4zLDAtMi4zLDEtMi4zLDIuM3YxLjNjMCwwLjUsMC40LDAuOSwwLjksMXYxMC41YzAsMS4zLDEsMi4zLDIuMywyLjNoOC41YzEuMywwLDIuMy0xLDIuMy0yLjNWOC4yYzAuNS0wLjEsMC45LTAuNSwwLjktMVY1LjlDMTguNCw0LjYsMTcuNCwzLjYsMTYuMSwzLjZ6IE05LjEsMy4zYzAtMC42LDAuNS0xLjEsMS4xLTEuMWgxLjdjMC42LDAsMS4xLDAuNSwxLjEsMS4xdjAuMkg5LjFWMy4zeiBNMTYuMywxOC43YzAsMC42LTAuNSwxLjEtMS4xLDEuMUg2LjdjLTAuNiwwLTEuMS0wLjUtMS4xLTEuMVY4LjJoMTAuNkwxNi4zLDE4LjdMMTYuMywxOC43eiBNMTcuMiw3SDQuOFY1LjljMC0wLjYsMC41LTEuMSwxLjEtMS4xaDEwLjJjMC42LDAsMS4xLDAuNSwxLjEsMS4xVjd6XFxcIi8+PC9nPjxnPjxnPjxwYXRoIGNsYXNzPVxcXCJmaWxsXFxcIiBkPVxcXCJNMTEsMThjLTAuNCwwLTAuNi0wLjMtMC42LTAuNnYtNi44YzAtMC40LDAuMy0wLjYsMC42LTAuNnMwLjYsMC4zLDAuNiwwLjZ2Ni44QzExLjYsMTcuNywxMS40LDE4LDExLDE4elxcXCIvPjwvZz48Zz48cGF0aCBjbGFzcz1cXFwiZmlsbFxcXCIgZD1cXFwiTTgsMThjLTAuNCwwLTAuNi0wLjMtMC42LTAuNnYtNi44QzcuNCwxMC4yLDcuNywxMCw4LDEwYzAuNCwwLDAuNiwwLjMsMC42LDAuNnY2LjhDOC43LDE3LjcsOC40LDE4LDgsMTh6XFxcIi8+PC9nPjxnPjxwYXRoIGNsYXNzPVxcXCJmaWxsXFxcIiBkPVxcXCJNMTQsMThjLTAuNCwwLTAuNi0wLjMtMC42LTAuNnYtNi44YzAtMC40LDAuMy0wLjYsMC42LTAuNmMwLjQsMCwwLjYsMC4zLDAuNiwwLjZ2Ni44QzE0LjYsMTcuNywxNC4zLDE4LDE0LDE4elxcXCIvPjwvZz48L2c+PC9nPjwvc3ZnPic7XFxyXFxuY29uc3QgY29tcGxldGVTVkcgPSAnPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJMYXllcl8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDIyIDIyXFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMiAyMjtcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPjxyZWN0IHk9XFxcIjBcXFwiIGNsYXNzPVxcXCJub0ZpbGxcXFwiIHdpZHRoPVxcXCIyMlxcXCIgaGVpZ2h0PVxcXCIyMlxcXCIvPjxnPjxwYXRoIGNsYXNzPVxcXCJmaWxsXFxcIiBkPVxcXCJNOS43LDE0LjRMOS43LDE0LjRjLTAuMiwwLTAuNC0wLjEtMC41LTAuMmwtMi43LTIuN2MtMC4zLTAuMy0wLjMtMC44LDAtMS4xczAuOC0wLjMsMS4xLDBsMi4xLDIuMWw0LjgtNC44YzAuMy0wLjMsMC44LTAuMywxLjEsMHMwLjMsMC44LDAsMS4xbC01LjMsNS4zQzEwLjEsMTQuMyw5LjksMTQuNCw5LjcsMTQuNHpcXFwiLz48L2c+PC9zdmc+JztcXHJcXG5cXHJcXG5cXHJcXG4vLyBVc2VyIGNsaWNrZWQgb24gdGhlIGFkZCBidXR0b25cXHJcXG4vLyBJZiB0aGVyZSBpcyBhbnkgdGV4dCBpbnNpZGUgdGhlIGl0ZW0gZmllbGQsIGFkZCB0aGF0IHRleHQgdG8gdGhlIHRvZG8gbGlzdFxcclxcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xcclxcbiAgICBsZXQgdmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaXRlbScpLnZhbHVlO1xcclxcbiAgICBpZiAodmFsdWUpIHtcXHJcXG4gICAgICAgIGFkZEl0ZW1Ub2RvKHZhbHVlKTtcXHJcXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpdGVtJykudmFsdWUgPSAnJztcXHJcXG4gICAgfVxcclxcbn0pO1xcclxcblxcclxcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpdGVtJykuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XFxyXFxuICAgIGxldCB2YWx1ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWU7XFxyXFxuXFxyXFxuICAgIGlmICgoZXZlbnQuY29kZSA9PT0gJ0VudGVyJyB8fCBldmVudC5jb2RlID09PSAnTnVtcGFkRW50ZXInKSAmJiB2YWx1ZSkge1xcclxcbiAgICAgICAgYWRkSXRlbVRvZG8odmFsdWUpO1xcclxcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2l0ZW0nKS52YWx1ZSA9ICcnO1xcclxcbiAgICB9XFxyXFxufSk7XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuY29uc3QgY2hhbmdlSXRlbSA9IChldmVudCkgPT4ge1xcclxcbiAgICBsZXQgaXRlbSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbMF07XFxyXFxuICAgIGxldCBpdGVtQ2hhbmdlID0gZXZlbnQuY3VycmVudFRhcmdldDtcXHJcXG4gICAgY29uc29sZS5sb2coaXRlbSk7XFxyXFxuXFxyXFxuICAgIGlmIChpdGVtLmRpc2FibGVkID09IHRydWUpIHtcXHJcXG4gICAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xcclxcbiAgICAgICAgaXRlbS5zdHlsZS5jdXJzb3IgPSAndGV4dCc7XFxyXFxuICAgICAgICBpdGVtLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgIzI1Yjk5YSc7XFxyXFxuICAgICAgICBpdGVtLmZvY3VzKCk7XFxyXFxuXFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtcXHJcXG4gICAgICAgIGl0ZW0uc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xcclxcbiAgICAgICAgaXRlbS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICM4Mzg0ODUnO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmNvbnN0IHJlbW92ZUl0ZW0gPSAoZXZlbnQpID0+IHtcXHJcXG4gICAgbGV0IGl0ZW0gPSBldmVudC5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUucGFyZW50Tm9kZTtcXHJcXG4gICAgbGV0IHBhcmVudCA9IGl0ZW0ucGFyZW50Tm9kZTtcXHJcXG5cXHJcXG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGl0ZW0pO1xcclxcbn1cXHJcXG5cXHJcXG5jb25zdCBjb21wbGV0ZUl0ZW0gPSAoZXZlbnQpID0+IHtcXHJcXG4gICAgbGV0IGl0ZW0gPSBldmVudC5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUucGFyZW50Tm9kZTtcXHJcXG4gICAgbGV0IHBhcmVudCA9IGl0ZW0ucGFyZW50Tm9kZTtcXHJcXG4gICAgbGV0IGlkID0gcGFyZW50LmlkO1xcclxcbiAgICBsZXQgdmFsdWUgPSBpdGVtLmlubmVyVGV4dDtcXHJcXG5cXHJcXG4gICAgLy89PT09PSBDaGVjayBpZiB0aGUgaXRlbSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGNvbXBsZXRlZCBsaXN0IG9yIHRvIHJlLWFkZGVkIHRvIHRoZSB0b2RvIGxpc3RcXHJcXG4gICAgbGV0IHRhcmdldCA9IChpZCA9PT0gJ3RvZG8nKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb21wbGV0ZWQnKSA6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b2RvJyk7XFxyXFxuXFxyXFxuICAgIHBhcmVudC5yZW1vdmVDaGlsZChpdGVtKTtcXHJcXG4gICAgdGFyZ2V0Lmluc2VydEJlZm9yZShpdGVtLCB0YXJnZXQuY2hpbGROb2Rlc1swXSk7XFxyXFxufVxcclxcblxcclxcbi8vPT09PT0gQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSB0byBkbyBsaXN0XFxyXFxuXFxyXFxuY29uc3QgYWRkSXRlbVRvZG8gPSAodGV4dCkgPT4ge1xcclxcbiAgICBsZXQgbGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b2RvJyk7XFxyXFxuICAgIGxldCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcXHJcXG4gICAgaXRlbS5zZXRBdHRyaWJ1dGUoXFxcImRyYWdnYWJsZVxcXCIsIHRydWUpO1xcclxcblxcclxcbiAgICBsZXQgaXRlbUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcXHJcXG4gICAgaXRlbUlucHV0LnNldEF0dHJpYnV0ZShcXFwiZGlzYWJsZWRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcclxcbiAgICBpdGVtSW5wdXQuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xcclxcbiAgICBpdGVtSW5wdXQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjODM4NDg1JztcXHJcXG4gICAgaXRlbUlucHV0LnZhbHVlID0gdGV4dDtcXHJcXG5cXHJcXG4gICAgbGV0IGJ1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXHJcXG4gICAgYnV0dG9ucy5jbGFzc0xpc3QuYWRkKCdidXR0b25zJyk7XFxyXFxuXFxyXFxuICAgIGxldCBjaGFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXHJcXG4gICAgY2hhbmdlLmNsYXNzTGlzdC5hZGQoJ2NoYW5nZScpO1xcclxcbiAgICBjaGFuZ2UuaW5uZXJIVE1MID0gY2hhbmdlU1ZHO1xcclxcblxcclxcbiAgICBsZXQgcmVtb3ZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XFxyXFxuICAgIHJlbW92ZS5jbGFzc0xpc3QuYWRkKCdyZW1vdmUnKTtcXHJcXG4gICAgcmVtb3ZlLmlubmVySFRNTCA9IHJlbW92ZVNWRztcXHJcXG5cXHJcXG4gICAgbGV0IGNvbXBsZXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XFxyXFxuICAgIGNvbXBsZXRlLmNsYXNzTGlzdC5hZGQoJ2NvbXBsZXRlJyk7XFxyXFxuICAgIGNvbXBsZXRlLmlubmVySFRNTCA9IGNvbXBsZXRlU1ZHO1xcclxcblxcclxcbiAgICAvLz09PT09IEFkZCBjbGljayBldmVudCBmb3IgY2hhbmdpbmcgJiByZW1vdmluZyAmIGNvbXBsaXRpbmcgaXRlbXNcXHJcXG4gICAgY2hhbmdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hhbmdlSXRlbSk7XFxyXFxuICAgIHJlbW92ZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJlbW92ZUl0ZW0pO1xcclxcbiAgICBjb21wbGV0ZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNvbXBsZXRlSXRlbSk7XFxyXFxuXFxyXFxuICAgIC8vPT09PT0gYXBwZW5kQ2hpbGRcXHJcXG5cXHJcXG4gICAgYnV0dG9ucy5hcHBlbmRDaGlsZChjaGFuZ2UpO1xcclxcbiAgICBidXR0b25zLmFwcGVuZENoaWxkKHJlbW92ZSk7XFxyXFxuICAgIGJ1dHRvbnMuYXBwZW5kQ2hpbGQoY29tcGxldGUpO1xcclxcbiAgICBpdGVtLmFwcGVuZENoaWxkKGl0ZW1JbnB1dCk7XFxyXFxuICAgIGl0ZW0uYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XFxyXFxuICAgIGxpc3QuaW5zZXJ0QmVmb3JlKGl0ZW0sIGxpc3QuY2hpbGROb2Rlc1swXSk7XFxyXFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NvdXJjZS9qcy9tYWluLmpzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7Il19
